<!DOCTYPE html >
<html lang="ru">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta http-equiv="Content-Script-Type" content="text/javascript">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" > <!--  tell the mobile browser to disable unwanted scaling of the page and set it to its actual size -->

	<script src="internationalisation/internationalisation.js"></script> <!-- там определяются переменные, используемые в загружаемых скриптах -->
    <!-- Leaflet -->
	<link rel="stylesheet" href="leaflet/leaflet.css" type="text/css">
	<script src="leaflet/leaflet.js"></script>
    <script src="Leaflet.RotatedMarker/leaflet.rotatedMarker.js"></script>
    <!-- Leaflet sidebar -->
    <link rel="stylesheet" href="leaflet-sidebar-v2/css/leaflet-sidebar.min.css" />
	<script src="leaflet-sidebar-v2/js/leaflet-sidebar.min.js"></script>

	<link rel="stylesheet" href="leaflet-omnivorePATCHED/leaflet-omnivore.css" />
	<script src="leaflet-omnivorePATCHED/leaflet-omnivore.js"></script>
	<script src="Leaflet.Editable/src/Leaflet.Editable.js"></script>

	<link rel="stylesheet" href="leaflet-measure-path/leaflet-measure-path.css" />
	<script src="leaflet-measure-path/leaflet-measure-path.js"></script>

    <script src="L.TileLayer.Mercator/src/L.TileLayer.Mercator.js"></script>
	<script src='supercluster/supercluster.js'></script>
	<script src="leaflet-tracksymbolPATCHED/leaflet-tracksymbol.js"></script>

	<script src="coordinate-parserPATCHED/coordinates.js">	</script>
	<script src="coordinate-parserPATCHED/validator.js"></script>
	<script src="coordinate-parserPATCHED/coordinate-number.js"></script> 
	
	<link rel="stylesheet" href="galadrielmap.css" type="text/css"> <!-- замена стилей -->
	<script src="galadrielmap.js"></script>
	<script src="options.js"></script>
   <title>GaladrielMap SignalK ed.</title>
   <!-- карта на весь экран -->
   <style>
body {
    padding: 0;
    margin: 0;
}
html, body, #mapid {
    height: 100%;
    width: 100vw;
}
   </style>
</head>
<body>
<div id="sidebar" class="leaflet-sidebar collapsed">
	<!-- Nav tabs -->
	<div class="leaflet-sidebar-tabs">
		<ul role="tablist" id="featuresList">
			<li id="homeTab"><a href="#home" role="tab"><img src="img/maps.svg" alt="menu" width="70%"></a></li>
			<li id="dashboardTab"><a href="#dashboard" role="tab"><img src="img/speed1.svg" alt="dashboard" width="70%"></a></li>
			<li id="tracksTab"><a href="#tracks" role="tab"><img src="img/track.svg" alt="tracks" width="70%" OnClick='loggingCheck();'></a></li>
			<li id="measureTab" ><a href="#measure" role="tab"><img src="img/route.svg" alt="Create route" width="70%"></a></li>
			<li id="routesTab"><a href="#routes" role="tab"><img src="img/poi.svg" alt="Routes and POI" width="70%"></a></li>
		</ul>
		<ul role="tablist" id="settingsList">
			<li id="MOBtab"><a href="#MOB" role="tab"><img src="img/mob.svg" alt="activate MOB" width="70%"></a></li>
			<li><a href="#settings" role="tab"><img src="img/settings1.svg" alt="settings" width="70%"></a></li>
		</ul>
	</div>
	<!-- Tab panes -->
	<div class="leaflet-sidebar-content" id='tabPanes'>
<!--
<div id='infoBox' style='font-size: 90%; position: absolute;'>
</div>
<script>
infoBox.innerText='width: '+window.outerWidth+' height: '+window.outerHeight;
</script>
-->
		<!-- Карты -->
		<div class="leaflet-sidebar-pane" id="home">
			<h1 class="leaflet-sidebar-header leaflet-sidebar-close"> <span id="homeHeaderTXT"></span> <span class="leaflet-sidebar-close-icn"><img src="img/Triangle-left.svg" alt="close" width="16px"></span></h1>
			<br>
			<ul id="mapDisplayed" class='commonList'>
			</ul>
			<ul id="mapList" class='commonList'>
					<li hiden class="template" onClick="{selectMap(event.currentTarget)}"></li>
			</ul>
		</div>
		<!-- Приборы -->
		<div class="leaflet-sidebar-pane" id="dashboard" style="height:100%;">
			<h1 class="leaflet-sidebar-header leaflet-sidebar-close"> <span id="dashboardHeaderTXT"></span> <span class="leaflet-sidebar-close-icn"><img src="img/Triangle-left.svg" alt="close" width="16px"></span></h1>
			<div class="big_symbol"> <!-- передвинуть карту на место курсора -->
				<div>
					<div style="line-height:0.6;" onClick="map.setView(cursor.getLatLng());">				
						<div style="font-size:50%;"><span id="dashboardSpeedTXT"></span></div><br>
						<div id='velocityDial'></div><br>
						<div style="font-size:50%;"><span id="dashboardSpeedMesTXT"></span></div>
					</div>
					<div id='depthDial' style="line-height:0.4;" onClick="map.setView(cursor.getLatLng());">				
					</div>
					<div style="line-height:0.6;" onClick="map.setView(cursor.getLatLng());">
						<br><span style="font-size:50%;"><span id="dashboardHeadingTXT"></span></span>
						<span style="font-size:30%; "><br><span id="dashboardHeadingAltTXT"></span></span>
					</div>
					<div style="">
						<span id='headingDisplay'></span>
					</div>
					<div style="font-size:50%;line-height:0.6;" onClick="doCopyToClipboard(lat+' '+lng);" >
						<br><span style="font-size:50%;" id="mobPosTXT"></span><br>
						<span style="font-size:30%;" id="mobPosAltTXT"></span>
					</div>
					<div style="font-size:50%;" onClick="doCopyToClipboard(lat+' '+lng);">
						<span id='locationDisplay'></span>
					</div>
				</div>
			</div>
			<div class="scaledText" style="text-align:center; position: absolute; bottom: 0;">
				<span id="dashboardSpeedZoomTXT"></span> <span id='velocityVectorLengthInMnDisplay'></span> <span id="dashboardSpeedZoomMesTXT"></span>.
			</div>
		</div>
		<!-- Треки -->
		<div class="leaflet-sidebar-pane" id="tracks">
			<h1 class="leaflet-sidebar-header leaflet-sidebar-close"> <span id="tracksHeaderTXT"></span> <span class="leaflet-sidebar-close-icn"><img src="img/Triangle-left.svg" alt="close" width="16px"></span></h1>
			<div style="margin: 1rem;">
				<div class="onoffswitch" style="float:right;margin: 1rem auto;"> 
					<input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="loggingSwitch" onChange="loggingRun();" >
					<label class="onoffswitch-label" for="loggingSwitch">
						<span class="onoffswitch-inner"></span>
						<span class="onoffswitch-switch"></span>
					</label>
				</div>
				<div style="padding:1rem 0 0 0;font-size:120%">
					<span id="loggingIndicator" style="font-size:100%;"></span> <span id="loggingTXT"></span>
				</div>
			</div>
			<ul id="trackDisplayed" class='commonList'>
			</ul>
			<ul id="trackList" class='commonList'>
				<li hidden class="template" onClick='{selectTrack(event.currentTarget,trackList,trackDisplayed,displayTrack)}' class='currentTrackName' title='Current track'></li>
			</ul>
		</div>
		<!-- Расстояния -->
		<div class="leaflet-sidebar-pane" id="measure">
			<h1 class="leaflet-sidebar-header leaflet-sidebar-close"> <span id="measureHeaderTXT"></span> <span class="leaflet-sidebar-close-icn"><img src="img/Triangle-left.svg" alt="close" width="16px"></span></h1>
			<!-- Кнопки создания/редактирования маршрута -->
			<div id='routeControls' class="routeControls" style="padding:1rem 0 2rem; text-align: center;">
				<input type="radio" name="routeControl" class='L' id="routeCreateButton"
					onChange="
						if(L.Browser.mobile && L.Browser.touch) var weight = 15; 	// мобильный браузер
						else var weight = 7; 	// стационарный браузер
						//window.LAYER = map.editTools.startPolyline(false,{showMeasurements: true,color: '#ccff00',weight: weight,opacity: 0.7});
						window.LAYER = map.editTools.startPolyline(false,{showMeasurements: true,color: '#FDFF00',weight: weight,opacity: 0.5});
                        //console.log(window.LAYER);
				        window.LAYER.on('click', L.DomEvent.stop).on('click', tooggleEditRoute);
						measuredPaths.push(window.LAYER);
						routeEraseButton.disabled=false;
						currentRoute = window.LAYER; 	// сделаем объект, по которому щёлкнули, текущим
						if(!routeSaveName.value || Date.parse(routeSaveName.value)) routeSaveName.value = new Date().toJSON(); 	// запишем в поле ввода имени дату, если там ничего не было или была дата
					"
				>
				<label for="routeCreateButton"><span id="routeControlsBeginTXT"></span></label>
				<input type="radio" name="routeControl" class='R' id="routeContinueButton"
					onChange="
						map.once('editable:vertex:click', function f(e) { // это CancelableVertexEvent
	                        //console.log(e);
	                        //console.log(e.vertex);
	                        e.cancel(); 	// прекратить дальнейшую обработку
	                        //e.vertex.split();
							e.vertex.continue();
							routeCreateButton.checked=true;
						});
					"
				>
				<label for="routeContinueButton"><span id="routeControlsContinueTXT"></span></label><br>
				<br>
				<input type="radio" name="routeControl" id="routeEraseButton"
					onChange="
						delShapes(true);
						routeControlsDeSelect();
						this.disabled=true;
						routeContinueButton.disabled=true;
					"
				>
				<label for="routeEraseButton"><span id="routeControlsClearTXT"></span></label>
			</div>
			<!-- Поиск места -->
			<div style="width:95%;">
				<div style="margin:0;padding:0;">
					<button onClick='goToPositionField.value += "°";goToPositionField.focus();' style="width:2rem;height:1.5rem;margin:0 0.7rem 0 0;"><span style="font-weight: bold; font-size:150%;">°</span></button>
					<button onClick='goToPositionField.value += "′";goToPositionField.focus();' style="width:2rem;height:1.5rem;margin:0 0.7rem 0 0;"><span style="font-weight: bold; font-size:150%;">′</span></button>
					<button onClick='goToPositionField.value += "″";goToPositionField.focus();' style="width:2rem;height:1.5rem;margin:0 0rem 0 0;"><span style="font-weight: bold; font-size:150%;">″</span></button><br>
				</div>
				<span id="routePosTXT"></span><br>
				<input id = 'goToPositionField' type="text" title="" size='12' style='width:11rem;font-size:150%;'>			
				<button id = 'goToPositionButton' onClick='flyByString(this.value);' style="width:3rem;padding:0.2rem;float:right;"><img src="img/ok.svg" alt="Ok" width="16px"></button><br>
			</div>
			<div  style='width:98%;height:12rem;overflow:auto;margin:0.3rem 0;'>
				<ul id='geocodedList' class='commonList'>
				</ul>
			</div>
			<!-- Сохранение маршрута -->
			<div style="width:95%; padding: 1rem 0; text-align: center;">
				<h3 id="routeSaveTitle"></h3>
				<input id = 'routeSaveName' type="text" title="" placeholder='' size='255' style='width:95%;font-size:150%;'>
				<textarea id = 'routeSaveDescr' title="" rows='5' cols='255' placeholder='' style='width:93%;padding: 0.5rem 3%;'></textarea>
				<button onClick='saveGPX();' type='submit' style="margin-top:5px;width:4rem;padding:0.2rem;float:right;"><img src="img/ok.svg" alt="Ok" width="16px"></button>
				<div id='routeSaveMessage' style='margin: 1rem;'></div>
			</div>			
		</div>
		<!-- Места и маршруты -->
		<div class="leaflet-sidebar-pane" id="routes">
			<h1 class="leaflet-sidebar-header leaflet-sidebar-close"> <span id="routesHeaderTXT"></span> <span class="leaflet-sidebar-close-icn"><img src="img/Triangle-left.svg" alt="close" width="16px"></span></h1>
			<ul id="routeDisplayed" class='commonList'>
			</ul>
			<ul id="routeList" class='commonList'>
				<li hiden class="template" onClick='{selectTrack(event.currentTarget,routeList,routeDisplayed,displayRoute)}'></li>
			</ul>
		</div>
		<!-- MOB -->
		<div class="leaflet-sidebar-pane" style="height:90%;" id="MOB">
			<h1 class="leaflet-sidebar-header leaflet-sidebar-close" style="background-color:red;"><span id="mobTXT"></span><span class="leaflet-sidebar-close-icn"><img src="img/Triangle-left.svg" alt="close" width="16px"></span></h1>
			<div style="margin: 1rem 1rem;width:90%;text-align: center;">
				<button onClick='MOBalarm();' style="width:75%;"><span style=""><span id="addMarkerTXT"></span></span></button>
			</div>
			<div class="big_symbol" style="line-height: normal;align-items: center;height:70%;" onClick="map.setView(currentMOBmarker.getLatLng());"> <?php //  передвинуть карту на место текущего маркера MOB ?>
				<div style=''><!-- объемлющий div необходим -->
						<div style="font-size:40%;">
							<span style="font-size:50%;display:block;" id="bearingTXT"></span>
							<span style="font-size:40%;display:block;" id="altBearingTXT"></span>
							<span style="margin:0.5rem;display:block;" id='azimuthMOBdisplay'> </span>
						</div>
						<div style="font-size:65%;margin:1rem 0;">
							<span style="font-size:40%;display:block;"><span id="distanceTXT"></span>, <span id="dashboardMeterMesTXT"></span></span>
							<span style="font-size:30%;display:block;" id="altDistanceTXT"></span>
							<span style="margin:0.5rem;display:block;" id='distanceMOBdisplay'> </span>
							<span style="font-size:75%;margin:0.5rem;display:block;" id='directionMOBdisplay'></span>
						</div>
						<div style="font-size:40%;" onClick="doCopyToClipboard(Math.round(currentMOBmarker.getLatLng().lat*10000)/10000+' '+Math.round(currentMOBmarker.getLatLng().lng*10000)/10000);" >
							<span style="font-size:50%;display:block;" id="dashboardPosTXT"></span>
							<span style="font-size:40%;display:block;" id="dashboardPosAltTXT"></span>
							<span style="margin:0.3rem;display:block;" id='locationMOBdisplay'></span>
						</div>
				</div>
			</div>
			<div style="position: absolute; bottom: 1rem;width:90%;text-align: center;"> <!-- Отбой -->
				<button onClick='delMOBmarker();' id='delMOBmarkerButton' style="width:80%;margin:1rem 0;font-size:75%;" disabled ><span style="" id="removeMarkerTXT"></span></button>
				<div>
				<a style="position:relative;left:-1rem;font-size:100%;color:gray;" onClick='
					this.nextElementSibling.disabled=false;
					this.style.color="green";
				'>&#x2B24;</a>
				<button onClick='MOBclose();' style="width:75%;" disabled><span style="" id="cancelMOBTXT"></span></button>
				</div>
			</div>
		</div>
		<!-- Настройки -->
		<div class="leaflet-sidebar-pane" id="settings">
			<h1 class="leaflet-sidebar-header leaflet-sidebar-close"><span id="settingsHeaderTXT"></span> <span class="leaflet-sidebar-close-icn"><img src="img/Triangle-left.svg" alt="close" width="16px"></span></h1>
			<div style="margin: 1rem 1rem;"> <!-- Следование за курсором -->
				<div class="onoffswitch" style="float:right;margin: 1rem auto;"> <!--  Переключатель https://proto.io/freebies/onoff/  -->
					<input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="followSwitch" onChange="noFollowToCursor=!noFollowToCursor; CurrnoFollowToCursor=noFollowToCursor;" checked>
					<label class="onoffswitch-label" for="followSwitch">
						<span class="onoffswitch-inner"></span>
						<span class="onoffswitch-switch"></span>
					</label>
				</div>
				<span style="font-size:120%" id="settingsCursorTXT"></span>
			</div>
			<div style="margin: 1rem 1rem;"> <!-- Текущий трек всегда показывается -->
				<div class="onoffswitch" style="float:right;margin: 1rem auto;"> <!--  Переключатель https://proto.io/freebies/onoff/  -->
					<input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="currTrackSwitch" onChange="" checked>
					<label class="onoffswitch-label" for="currTrackSwitch">
						<span class="onoffswitch-inner"></span>
						<span class="onoffswitch-switch"></span>
					</label>
				</div>
				<span style="font-size:120%" id="settingsTrackTXT"></span>
			</div>
			<div style="margin: 1rem 1rem;"> <!-- Выбранные маршруты всегда показываются -->
				<div class="onoffswitch" style="float:right;margin: 1rem auto;"> <!--  Переключатель https://proto.io/freebies/onoff/  -->
					<input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="SelectedRoutesSwitch" onChange="">
					<label class="onoffswitch-label" for="SelectedRoutesSwitch">
						<span class="onoffswitch-inner"></span>
						<span class="onoffswitch-switch"></span>
					</label>
				</div>
				<span style="font-size:120%" id="settingsRoutesAlwaysTXT"></span>
			</div>
			<br><br>
			<div style="margin: 1rem 1rem;"> <!-- Показ целей AIS -->
				<div class="onoffswitch" style="float:right;margin: 0 auto;"> <!--  Переключатель https://proto.io/freebies/onoff/  -->
					<input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="DisplayAISswitch" onChange="watchAISswitching();">
					<label class="onoffswitch-label" for="DisplayAISswitch">
						<span class="onoffswitch-inner"></span>
						<span class="onoffswitch-switch"></span>
					</label>
				</div>
				<span style="font-size:120%;vertical-align:middle;" id="DisplayAIS_TXT"></span>
			</div>
			<br><br>
			<div style="margin: 1rem 1rem;"> <!-- максимальная скорость обновления -->
				<div style="float:right;margin: 1rem auto;">
					<input id='minWATCHintervalInput' type="text" pattern="[0-9]*" title="" size='4' style='width:3rem;font-size:175%;'
					 onChange="minWATCHinterval=parseFloat(this.value);
					 if(isNaN(minWATCHinterval)) minWATCHinterval=0;
					 //console.log('Изменение, minWATCHinterval',minWATCHinterval);
					 spatialWebSocketStop('Close socket to change WATCH interval');
					 watchAISstop('Close socket to change WATCH interval');
					"
					>
				</div>
				<span style="font-size:120%;vertical-align:middle;" id="minWATCHintervalTXT"></span>
			</div>
		</div>
	</div>
</div>
<div id="mapid" ></div>
</body>

<script> "use strict";
// Карта
var defaultMap = 'world-coastline'; 	// chart-plugin identifier Карта, которая показывается, если нечего показывать. Народ интеллектуальный ценз ниасилил.
var savedLayers = []; 	// массив для хранения объектов, когда они не на карте
var additionalTileCachePath = ''; 	// дополнительный кусок пути к тайлам между именем карты и /z/x/y.png Используется в версионном кеше, например, в погоде. Без / в конце, но с / в начале, либо пусто. Присваивается в javascriptOpen в параметрах карты. Или ещё где-нибудь.
var startCenter = JSON.parse(getCookie('GaladrielMapPosition')); 	// getCookie from galadrielmap.js
if(! startCenter) startCenter = L.latLng([55.754,37.62]); 	// начальная точка
var startZoom = JSON.parse(getCookie('GaladrielMapZoom')); 	// getCookie from galadrielmap.js
if(! startZoom) startZoom = 12; 	// начальный масштаб
var userMoveMap = true; 	// флаг для отделения собственных движений карты от пользовательских. Считаем все пользовательскими, и только где надо - выставляем иначе
// ГПС
var minWATCHinterval=JSON.parse(getCookie('GaladrielminWATCHinterval'));	// Минимальный интервал, сек., с которым будут приходить данные от gpsdPROXY. Если 0 -- то по мере их получения от датчиков
if(!minWATCHinterval) minWATCHinterval = 0;
minWATCHintervalInput.value = minWATCHinterval;
if(PosFreshBefore < (2*minWATCHinterval*1000+1000)) PosFreshBefore = 2*minWATCHinterval*1000+1000;	// PosFreshBefore в options.js
var heading = 0; 	// начальное направление
var followToCursor = true; 	// карта следует за курсором Обеспечивает только паузу следования при перемещениях и масштабировании карты руками
var noFollowToCursor = false; 	// карта никогда не следует за курсором Глобальное отключение следования. Само не восстанавливается.
var CurrnoFollowToCursor = 1; 	// глобальная переменная для сохранения состояния
var followPause = 10 * 1000; 	// пауза следования карты за курсором, когда карту подвинули руками, микросекунд
var savePositionEvery = 15 * 1000; 	// будем сохранять положение каждые микросекунд локально в куку
var followPaused; 	// объект таймера, который восстанавливает следование курсору
var velocityVectorLengthInMn = 10; 	// длинной в сколько минут пути рисуется линия скорости
// AIS
var vehicles = []; 	// list of visible by AIS data vehicle objects 
// Loader
var downJob = false; 	// флаг - не создаётся ли задание на скачивание
// Пути и маршруты
var currentTrackServerURI = 'getlasttrkpt'; 	// адрес для подключения к сервису, отдающему сегменты текущего трека
var trackDirURI = 'track'; 	// адрес каталога с треками
var routeDirURI = 'route'; 	// адрес каталога с маршрутами
var currentTrackName = ''; 	// имя текущего (пишущегося сейчас) трека
var updateRouteServerURI = 'checkRoutes'; 	// url службы динамического обновления маршрутов
if(getCookie('GaladrielcurrTrackSwitch') == undefined) currTrackSwitch.checked = true; 	// показывать текущий трек вместе с курсором
else currTrackSwitch.checked = Boolean(+getCookie('GaladrielcurrTrackSwitch')); 	// getCookie from galadrielmap.js
if(getCookie('GaladrielSelectedRoutesSwitch') == undefined) SelectedRoutesSwitch.checked = false; 	// показывать выбранные маршруты
else SelectedRoutesSwitch.checked = Boolean(+getCookie('GaladrielSelectedRoutesSwitch')); 	// getCookie from galadrielmap.js
var currentRoute; 	// объект Editable, по которому щёлкнули. Типа, текущий.
var globalCurrentColor = 0xFFFFFF; 	// цвет линий и  значков кластеров после первого набора
var currentTrackShowedFlag = false; 	// флаг, не показывается ли текущий путь. Если об этом спрашивать у Leaflet, то пока загружается трек, можно запустить его загрузку ещё раз пять.
// Dashboard
var lat; 	 	// широта
var lng; 	 	// долгота, округлённые до 4-х знаков
// Прокладка
var goToPositionManualFlag = false; 	// флаг, что поле goToPositionField стали редактировать руками, и его не надо обновлять
// MOB
var currentMOBmarker;
// main output data
var upData = {};
var vesselSelf;
var instanceSelf = getCookie('GaladrielMapInstance');	// идентификатор экземпляра программы
if(!instanceSelf) {
	instanceSelf = generateUUID();
	let expires =  new Date();
	expires.setTime(expires.getTime() + (60*24*60*60*1000)); 	// протухнет через два месяца
	document.cookie = "GaladrielMapInstance="+instanceSelf+"; expires="+expires+"; path=/; samesite=Lax";
}


// подготовка интерфейса, списков карт и треков, etc.
onBodyLoad()	

// Определим карту
var map = L.map('mapid', {
	center: startCenter,
    zoom: startZoom,
    attributionControl: false,
    zoomControl: false,
    editable: true
	}
);

// Controls
// Zoom в правом верхнем углу
L.control.zoom({
     position:'topright'
}).addTo(map);

// Версия и пр. в правом нижнем углу
var info = L.control.attribution({
	prefix: 'GaladrielMap SignalK edition '+versionTXT+' by Leaflet'
}
).addTo(map);

// Шкала масштаба
L.control.scale({
	position: 'bottomleft',
	maxWidth: 200,
	imperial: false
}
).addTo(map);

// control для записывания в clipboard
var copyToClipboard = new L.Control.CopyToClipboard({ 	// класс определён в galadrielmap.js
	position: 'bottomright'
}); 	// на карту не добавляется


// Панель управления
var sidebar = L.control.sidebar('sidebar',{
	container: 'sidebar',
}).addTo(map);
sidebar.on("content", function(event){ 	// Событие открытия? панели 
	//alert(event.id);
	switch(event.id){ 	// какую вкладку открыли
	case 'measure': 	// рисование маршрута
		centerMarkOn(); 	// включить крестик в середине
		if(CurrnoFollowToCursor === 1)CurrnoFollowToCursor = noFollowToCursor;  // запомним состояние глобального признака следования за курсором, если ещё не запоминали
		noFollowToCursor = true; 	// отключим следование за курсором
		break;
	case 'MOB': 	// человек за бортом
		if(!map.hasLayer(mobMarker)) MOBalarm();
		break;
	}
});
sidebar.on("closing", function(){
	if(CurrnoFollowToCursor !== 1) noFollowToCursor = CurrnoFollowToCursor; 	// восстановим признак следования за курсором
	CurrnoFollowToCursor = 1;
	centerMarkOff(); 	// выключить крестик посередине
});
// end controls
// Поведение карты
map.on('movestart zoomstart', function(event) { 	// карту начали двигать руками
	// функция отменяет следование карты за курсором, и устанавливает таймер, чтобы вернуть
	// пытается отделить собственные движения карты от юзерских, включая изменение масштаба
	if(userMoveMap) { 	// Убран флаг в куске, двигающем карту за курсором
		//alert('Карту сдвинули событием '+event.type);
		if(event.type == 'zoomstart') userMoveMap = 2; // юзер нажал zoom
		else {
			if(userMoveMap == 2) userMoveMap = true; 	// на это дело сработало movestart - игнорируем
			else {
				followToCursor=false; 	// запретим следование за курсором
				clearTimeout(followPaused); 	// отменим то, что есть
				followPaused = setTimeout('followToCursor=true;',followPause); 	// через время followPause разрешим обратно
			}
		}
	}
});
map.on('zoomend', function(event) {
	let zoom = event.target.getZoom();	
});
map.on('moveend', updateClasters); 	// кластеризация точек POI
//map.on("layeradd", function(event) {
//});

// Восстановим слои
var layers = JSON.parse(getCookie('GaladrielMaps')); 	// getCookie from galadrielmap.js
// Занесём слои на карту
if(layers) layers.reverse().forEach(function(layerid){ 	// потому что они там были для красоты последним слоем вверъ
		for (var i = 0; i < mapList.children.length; i++) { 	// для каждого потомка списка mapList
			if (mapList.children[i].id==layerid) { 	// 
				selectMap(mapList.children[i]);
				break;
			}
		}
	});
else {
	for (var i = 0; i < mapList.children.length; i++) { 	// для каждого потомка списка mapList
		if (mapList.children[i].id==defaultMap) { 	// найдём, который из них defaultMap
			selectMap(mapList.children[i]); 	// и покажкм его
			break;
		}
	}
}


// Рисование маршрута
var measuredPaths = [];
doRestoreMeasuredPaths(); 	// восстановим из кук сохранённые на устройстве маршруты
routeControlsDeSelect(); 	// сделать кнопки рисования невыбранными
routeContinueButton.disabled=true; 	// сделать кнопку "Продолжить" неактивной.
routeEraseButton.disabled=true; 	// сделать кнопку "Стереть" неактивной.

map.on('editable:editing', // обязательный обработчик для editable для перересовывания расстояний при изменении пути
	function (e) {
		//console.log('обязательный обработчик для editable start by editable:editing');
		//console.log(e);
		//console.log(e.layer);
		if (e.layer instanceof L.Path) e.layer.updateMeasurements();
    }
);
map.on('editable:drawing:end', // выключать кнопку "Начать" при окончании рисования, сделать доступной "Продолжить"
	function () {
		//alert('Stop create'); 
		routeCreateButton.checked=false;
		routeContinueButton.disabled=false;
	}
);
map.on('editable:vertex:dragstart', 
	function (e) {
		window.navigator.vibrate(200); // Вибрировать 200ms
	}
)
var doSaveMeasuredPathsProcess = setInterval(doSaveMeasuredPaths,savePositionEvery); 	// велим сохранять каждые savePositionEvery

// центр экрана
let markSize = Math.round(window.innerWidth/5);
//console.log(markSize);
var centerMark = L.marker(map.getBounds().getCenter(), {
	'icon': new L.icon({
		iconUrl: './img/Crosshair.svg',
		iconSize:     [markSize, markSize], // size of the icon
		iconAnchor:   [markSize/2, markSize/2], // point of the icon which will correspond to marker's location
	})
});

// Местоположение
// маркеры
var GpsCursor = L.icon({
	iconUrl: './img/gpscursor.png',
	//shadowUrl: '//leafletjs.com/docs/images/leaf-shadow.png',
	iconSize:     [120, 120], // size of the icon
	//shadowSize:   [50, 64], // size of the shadow
	iconAnchor:   [60, 60], // point of the icon which will correspond to marker's location
	//shadowAnchor: [4, 62],  // the same for the shadow
	//popupAnchor:  [-3, -76] // point from which the popup should open relative to the iconAnchor
});

// курсор
var NoGpsCursor = L.icon({	// этот значёк может показываться и при пропаже связи с сервером, а в этом случае загрузить картинку не удастся. Попытка загрузить её заранее не получилась: Leaflet, видимо, убивает долго неиспользуемые объекты. Или сборщик мусора?
	iconUrl: './img/gpscursor.png',
	iconSize:     [120, 120], // size of the icon
	iconAnchor:   [60, 60], // point of the icon which will correspond to marker's location
	className: "NoGpsCursorIcon"	// galadrielmap.css
});
var velocityCursor = L.icon({
	iconUrl: './img/1x1.png',
	//iconUrl: './img/minLine.svg',
});
var NoCursor = L.icon({
	iconUrl: './img/1x1.png',
	iconSize: [0, 0], // size of the icon
});
var cursor = L.marker(startCenter, {
	'icon': GpsCursor,
	rotationAngle: heading, // начальный угол поворота маркера
	rotationOrigin: "50% 50%", 	// вертим маркер вокруг центра
});

// указатель скорости
var velocityVector = L.marker(cursor.getLatLng(), {
	'icon': velocityCursor,
	rotationAngle: heading, // начальный угол поворота маркера
	opacity: 0.1
});
velocityVectorLengthInMnDisplay.innerHTML = velocityVectorLengthInMn; 	// нарисуем цену вектора скорости на панели управления
// Точность ГПС
var GNSScircle = L.circle(cursor.getLatLng(), {
	'radius': 10,
	'color':'#000000',
	'weight':0,
	'opacity':0.1,
	'fillOpacity':0.1
});
var positionCursor = L.layerGroup([GNSScircle,velocityVector,cursor]);

// MOB marker
var mobIcon = L.icon({ 	// 
	iconUrl: mob_markerImg,	// options.js
	//iconUrl: "img/mob.png",
	iconSize: [32, 37],
	//iconSize: [64, 74],
	iconAnchor: [16, 37],
	//iconAnchor: [32, 74],
	tooltipAnchor: [16,-25],
	className: 'mobIcon'	
});
// линия между положением и указанным маркером MOB
var toMOBline = L.polyline([], { 	
	color: 'red',
	weight: 10,
	opacity:0.3,
})

// восстановим маркеры
var mobMarker = getCookie('GaladrielMapMOB'); 	// getCookie from galadrielmap.js
//console.log('Восстановление MOB: mobMarker',mobMarker);
if(mobMarker) {
	// Восстановим мультислой маркеров из GeoJSON, а потом каждому маркеру в мультислое присвоим иконку, которая в GeoJSON не сохраняется.
	mobMarker = L.geoJSON(JSON.parse(mobMarker));
	mobMarker.eachLayer(function (layer) {
		if(layer instanceof L.Marker)	{
			layer.setIcon(mobIcon);
			currentMOBmarker = layer; 	// последний станет текущим
		}
		else mobMarker.removeLayer(layer); 	// Считаем, что это toMOBline, и там больше ничего такого нет
	});
	mobMarker.addLayer(toMOBline);
	mobMarker.addTo(map);
	mobMarker.eachLayer(function (layer) { 	// сделаем каждый маркер draggable
		if(layer instanceof L.Marker)	{	
			layer.dragging.enable(); 	// переключение возможно, только если маркер на карте
			layer.on('dragend', function(event){
				//console.log("New MOB marker from server data dragged end, send to server new coordinates",currentMOBmarker);
				sendMOBtoServer(); 
			}); 	// отправим на сервер новые сведения, когда перемещение маркера закончилось. Если просто указать функцию -- в sendMOBtoServer передаётся event. Если в одну строку -- всё равно передаётся event. Что за???
		}
	});
}
else mobMarker = L.layerGroup().addLayer(toMOBline);

//var mobMarker = L.layerGroup().addLayer(toMOBline);

// Позиционирование
// Realtime периодическое обновление
var spatialWebSocket; // 
var TPVdata = {};	// буфер с данными позиционирования, скорости и направления
let lastDataUpdate;	// момент последнего обновления координат

function spatialWebSocketStart(){
//
	let checkDataFreshInterval;	// объект периодического запуска проверки свежести данных
	
	spatialWebSocket = new WebSocket(`ws://${document.location.host}/signalk/v1/stream?subscribe=none`); 	//  подписываться будем отдельно, по событию websocketOnOpen
	spatialWebSocket.onopen = function(event) {
		console.log("[spatialWebSocket open] Connection established");
		TPVsubscribe.subscribe.forEach(subscribe => subscribe.minPeriod = minWATCHinterval);	//  signalKsubscribe в options.js
		event.target.send(JSON.stringify(TPVsubscribe));	// подписываемся на получение данных
		console.log("[spatialWebSocket open] Subscribe sended");
		if(map.hasLayer(mobMarker)){ 	// если показывается мультислой с маркерами MOB
			sendMOBtoServer(); 	// отдадим данные MOB для передачи на сервер, на всякий случай -- вдруг там не знают
		}
		// Хоть какая-то проверка актуальности координат -- за отсутствием чего-то такого в SignalK
		if(useSystemTimeouts){	// options.js
			// Попытка сделать правильно в этом кривом SignalK
			// Во-первых, meta.timeout реально вообще нигде нет. По идее, его должен указывать производитель данных, но нет.
			// Во-вторых, к этому моменту может вообще не быть navigation, а по подписке не присылается meta
			// В-третьих, в доке указано, что должен быть meta.timeout, но если смотреть по аналогии с units, скажем, то оно meta.properties.longitude.timeout Как оно правильно -- неизвестно
			const timeout = getSelfPathC('navigation.position.meta.timeout');
			if(timeout) PosFreshBefore = timeout*1000;
		}
		checkDataFreshInterval = setInterval(function (){
			if((Date.now()-lastDataUpdate)>PosFreshBefore){
				console.log('The latest TPV data was received too long ago, trying to reconnect for checking.');
				spatialWebSocket.close(1000,'The latest data was received too long ago');
			}
		},PosFreshBefore);
	}; // end spatialWebSocket.onopen

	spatialWebSocket.onmessage = function(event) {
		//console.log(`[message] Данные TPV получены с сервера: ${event.data}`);
		let data;
		try{
			data = JSON.parse(event.data);
		}
		catch(error){
			console.log('spatialWebSocket: Parsing inbound data',error.message);
			return;
		}
		//console.log('From SignalK',data,vesselSelf);
		if(!data.updates){	// ответ на какой-то запрос
			//console.log('Other From SignalK',data);
			if(data.self){	// handshaiking
				vesselSelf = data.self.substring(8);	// vessels.
			}
			return;
		}
		byUpdates: for(let update of data.updates){
			//console.log('update:',update);
			if(!update.values) continue;	// непонятно, почему может не быть values, но иногда их нет
			for(let value of update.values){	// какое-то обновление данных пришло.
				//console.log('recieved data',data);
				lastDataUpdate = Date.now();
				switch(value.path){
				case 'navigation.position':
					TPVdata.lon = value.value.longitude;
					TPVdata.lat = value.value.latitude;
					//console.log('TPVdata lon lat',TPVdata.lon,TPVdata.lat);
					TPVdata.time = update.timestamp;	// там не требуется unix timestamp, а, наоборот, дата в виде строки
					break;
				case 'navigation.courseOverGroundTrue':
				case 'navigation.headingTrue':
				case 'navigation.headingMagnetic':
				case 'navigation.headingCompass':
					TPVdata.track = value.value*180/Math.PI;
					break;
				case 'navigation.speedOverGround':
				case 'navigation.speedThroughWater':
					TPVdata.speed = value.value;
					break;
				case 'environment.depth.belowSurface':
				case 'environment.depth.belowKeel':
				case 'environment.depth.belowTransducer':
					TPVdata.depth = value.value;
					break;
				case 'notifications.mob':
					//console.log('recieved MOB data',data);
					//console.log('recieved MOB data',data.context,value.path,value.value);
					
					// pre MOB -- даже если у нас нет координат, полезно показать маркеры MOB
					if(value.value === null) { 	// режим MOB надо выключить
						if(map.hasLayer(mobMarker)){ 	// если показывается мультислой с маркерами MOB
							MOBclose(); 	// пришло, что режима MOB нет -- завершим его
						}
						continue byUpdates;
					}
					//console.log('режим MOB есть, пришли новые данные');
					if(value.value.source == instanceSelf) continue byUpdates;	// это нами же установленный MOB
					let mobMarkerJSON = value.value.position;	// Это GeoJSON
					//console.log('mobMarkerJSON:',mobMarkerJSON);
					// Восстановим мультислой маркеров из GeoJSON, а потом каждому маркеру в мультислое присвоим иконку, которая в GeoJSON не сохраняется.
					mobMarker.remove(); 	// убрать мультислой-маркер с карты
					mobMarker = null; 	// реально удалим объект
					mobMarker = L.geoJSON(mobMarkerJSON); 	// создадим новый объект
					mobMarker.eachLayer(function (layer) {
						if(layer instanceof L.Marker)	{
							layer.setIcon(mobIcon);
							layer.on('click', function(ev){
								currentMOBmarker = ev.target;
								clearCurrentStatus(); 	// удалим признак current у всех маркеров
								currentMOBmarker.feature.properties.current = true;
								sendMOBtoServer(); 	// отдадим данные MOB для передачи на сервер
							}); 	// текущим будет маркер, по которому кликнули
							//console.log('Маркеры в полученной информации MOB ',layer);
							if(layer.feature.properties.current) currentMOBmarker = layer; 	// текущим станет указанный в переданных данных
						}
						else mobMarker.removeLayer(layer); 	// Считаем, что это toMOBline, и там больше ничего такого нет
					});
					mobMarker.addLayer(toMOBline);
					mobMarker.addTo(map); 	// покажем мультислой с маркерами MOB
					mobMarker.eachLayer(function (layer) { 	// сделаем каждый маркер draggable
						if(layer instanceof L.Marker)	{	
							layer.dragging.enable(); 	// переключение возможно, только если маркер на карте
							layer.on('dragend', function(event){
								//console.log("New MOB marker from server data dragged end, send to server new coordinates",currentMOBmarker);
								sendMOBtoServer(); 
							}); 	// отправим на сервер новые сведения, когда перемещение маркера закончилось. Если просто указать функцию -- в sendMOBtoServer передаётся event. Если в одну строку -- всё равно передаётся event. Что за???
						}
					});
					//console.log(mobMarker);
					break;
				}
			}
		}
		data = null;
		realtimeTPVupdate(TPVdata);	// показываем новое каждый тик
	}; // end spatialWebSocket.onmessage

	spatialWebSocket.onclose = function(event) {
		console.log(`spatialWebSocket closed: connection broken with code ${event.code} by reason ${event.reason}`);
		//console.log('lastDataUpdate',lastDataUpdate,'PosFreshBefore',PosFreshBefore);
		if((Date.now()-lastDataUpdate)>PosFreshBefore*30) positionCursor.remove(); 	// уберём курсор (layerGroup) с карты
		else {cursor.setIcon(NoGpsCursor);}	// заменим курсор (значёк) на серый
		velocityDial.innerHTML = '&nbsp;'; 	// обнулим панель приборов
		headingDisplay.innerHTML = '&nbsp;';
		locationDisplay.innerHTML = '&nbsp;';
		depthDial.innerHTML = '';
		//MOBtab.className='disabled'; 	// если нет курсора (координат) -- невозможно включить режим MOB. Это плохая идея.
		clearInterval(checkDataFreshInterval);	// остановить периодическую проверку свежести
		window.setTimeout(spatialWebSocketStart, 3000); 	// перезапустим сокет через  секунд. В каком контексте здесь вызывается callback -- мне осталось непонятным, поэтому сокет ваще глобален
	}; // end spatialWebSocket.onclose

	spatialWebSocket.onerror = function(error) {
	  console.log(`[spatialWebSocket error] ${error.message}`);
	}; // end spatialWebSocket.onerror

	function realtimeTPVupdate(gpsdData) {
		//console.log('Index gpsdData',gpsdData);
		//console.log('Index gpsdData.MOB',gpsdData.MOB);
		// Положение неизвестно
		//console.log('Index gpsdData',gpsdData.lon,gpsdData.lat);
		if(gpsdData.error || (gpsdData.lon == null)||(gpsdData.lat == null) || (gpsdData.lon == undefined)||(gpsdData.lat == undefined)) { 	// 
			console.log('No spatial info in GPSD data',gpsdData);
			positionCursor.remove(); 	// уберём курсор с карты
			velocityDial.innerHTML = '&nbsp;'; 	// обнулим панель приборов
			headingDisplay.innerHTML = '&nbsp;';
			locationDisplay.innerHTML = '&nbsp;';
			depthDial.innerHTML = '';
			//MOBtab.className='disabled'; 	// если нет курсора (координат) -- невозможно включить режим MOB. Это плохая идея.
			return;
		}
		// Свежее ли положение известно
		//MOBtab.className=''; 	// координаты появились -- можно включить режим MOB
		cursor.setLatLng(L.latLng(gpsdData.lat,gpsdData.lon));
		var positionTime = new Date(gpsdData.time);
		var now = new Date();
		//console.log('gpsdData.time:',gpsdData.time,'now',now,'now-positionTime',now-positionTime);
		if((now-positionTime) > PosFreshBefore) cursor.setIcon(NoGpsCursor); 	// свежее положение было определено раньше, чем PosFreshBefore милисекунд назад
		else cursor.setIcon(GpsCursor);
		
		// Показ скорости и прочего
		//console.log('Index gpsdData',gpsdData.speed);
		var metresPerPixel = (40075016.686 * Math.abs(Math.cos(cursor.getLatLng().lat*(Math.PI/180))))/Math.pow(2, map.getZoom()+8); 	// in WGS84
		if(gpsdData.speed==undefined || gpsdData.speed==null) {
			velocityDial.innerHTML = '&nbsp;';
			velocityVector.setIcon(NoCursor);
		}
		else {
			//var velocity = Math.round((gpsdData.speed*60*60/1000)*10)/10; 	// скорость от gpsd - в метрах в секунду
			var velocity = Math.round((gpsdData.speed*60*60/1000)*10)/10; 	// скорость от gpsd - в метрах в секунду

			velocityDial.innerHTML = velocity;
			// Установим длину указателя скорости за  минуты
			var velocityCursorLength = gpsdData.speed*60*velocityVectorLengthInMn; 	// метров  за  минуты
			velocityCursorLength = Math.round(velocityCursorLength/metresPerPixel);
			//console.log('map.getZoom='+map.getZoom()+'\nmetresPerPixel='+metresPerPixel+'\ngpsdData.speed='+gpsdData.speed+'\nvelocityCursorLength='+velocityCursorLength);
			velocityCursor.options.iconSize=[5,velocityCursorLength];
			velocityCursor.options.iconAnchor=[3,velocityCursorLength];
			velocityVector.setIcon(velocityCursor); 	// изменить иконку у маркера
		}
		if(gpsdData.depth) {
			//console.log('Index gpsdData',gpsdData.depth);
			depthDial.innerHTML = '<br><br><div style="font-size:50%;">'+dashboardDepthMesTXT+'</div><br><div>'+(Math.round(gpsdData.depth*100)/100)+'</div><br><div style="font-size:50%;">'+dashboardMeterMesTXT+'</div>';
		}
		else {
			depthDial.innerHTML = '';
		}
		
		// Направление с попыткой его запомнить при прекращении движения
		//console.log('Index gpsdData',gpsdData.track);
		velocityVector.setLatLng( cursor.getLatLng() );// положение указателя скорости
		if(gpsdData.track == null || gpsdData.track == undefined) {
			headingDisplay.innerHTML = '&nbsp;';
			cursor.setRotationAngle(0); // повернём маркер
			velocityVector.setRotationAngle(0); // повернём указатель скорости
		}
		else {
			heading = gpsdData.track; // если положение изменилось - возьмём новое направление, иначе - будет старое.
			cursor.setRotationAngle(heading); // повернём маркер
			velocityVector.setRotationAngle(heading); // повернём указатель скорости
			headingDisplay.innerHTML = Math.round(heading); // покажем направление на приборной панели
		}
		positionCursor.addTo(map); 	// добавить курсор на карту

		// Окружность точност ГПС
		var errGNSS = (+gpsdData.errX+gpsdData.errY)/2;
		if(!errGNSS) errGNSS = 10; // метров
		if(errGNSS/metresPerPixel > 15) GNSScircle.setRadius(errGNSS); 	// кружок точности больше кружка курсора
		else GNSScircle.setRadius(0);
		GNSScircle.setLatLng(cursor.getLatLng());

		// Карту в положение
		//console.log("followToCursor", followToCursor);
		if(followToCursor && (! noFollowToCursor)) { 	// если сказано следовать курсору, и это разрешено глобально
			userMoveMap = false;
			//map.fitBounds(realtime.getBounds(), {maxZoom: map.getZoom()});
			map.setView(cursor.getLatLng()); // подвинем карту на позицию маркера
			userMoveMap = true;
		}

		// координаты курсора с точностью знаков
		lat = Math.round(cursor.getLatLng().lat*10000)/10000; 	 	// широта
		lng = Math.round(cursor.getLatLng().lng*10000)/10000; 	 	// долгота
		//alert(cursor.getLatLng()+'\n'+lat+' '+lng);
		locationDisplay.innerHTML = latTXT+' '+lat+'<br>'+longTXT+' '+lng;	
		followSwitch.checked = !noFollowToCursor; 	// выставим переключатель на панели Настроек в текущее положение	
		
		// MOB
		if(map.hasLayer(mobMarker)){ 	// если показывается мультислой с маркерами MOB 
			//console.log(mobMarker.getLayers());
			let latlng1 = cursor.getLatLng();
			let latlng2 = currentMOBmarker.getLatLng();
			toMOBline.setLatLngs([latlng1,latlng2]); 	// обновим линию к текущему маркеру MOB
			// информация о MOB на панели
			const azimuth = bearing(latlng1, latlng2);
			//console.log('azimuth=',azimuth,latlng1, latlng2)
			azimuthMOBdisplay.innerHTML = Math.round(azimuth);
			distanceMOBdisplay.innerHTML = Math.round(latlng1.distanceTo(latlng2));
			locationMOBdisplay.innerHTML = latTXT+' '+Math.round(currentMOBmarker.getLatLng().lat*10000)/10000+' '+longTXT+' '+Math.round(currentMOBmarker.getLatLng().lng*10000)/10000;	
			if(gpsdData.track !== null) { 	// если доступен истинный курс, heading есть всегда
				let relBearing = azimuth-heading+22.5;	// половина от 45 против часовой стрелки
				if(relBearing<0) relBearing = 360+relBearing;
				relBearing = Math.floor(relBearing/45); 	// курсовой угол (relative bearing) / 45 градусов -- номер сектора, против часовой стрелки
				if(relBearing>7) relBearing = 0;
				directionMOBdisplay.innerHTML = relBearingTXT[relBearing];
			}
		}
	}; // end function realtimeTPVupdate
}; // end function spatialWebSocketStart

spatialWebSocketStart(); 	// запускам периодическую функцию получать TPV

function spatialWebSocketStop(message=''){
	console.log('Stop recieve TPV',);
	spatialWebSocket.close(1000,message);
} // end function spatialWebSocketStop


// Данные AIS
// 	Запуск периодических функций
var aisWebSocket;	// будет глобальный сокет для AIS
var AISdata = {};	// буфер с данными AIS
function watchAISstart() {
	//console.log('AIS switched ON');
	let checkDataFreshInterval;	// объект периодического запуска проверки свежести данных

	aisWebSocket = new WebSocket(`ws://${document.location.host}/signalk/v1/stream?subscribe=none`); 	//  подписываться будем отдельно, по событию websocketOnOpen
	aisWebSocket.onopen = function(event) {
		console.log("[aisWebSocket open] Connection established");
		AISsubscribe.subscribe.forEach(subscribe => subscribe.minPeriod = minWATCHinterval);	//  AISsubscribe в options.js
		event.target.send(JSON.stringify(AISsubscribe));	// подписываемся на получение данных
		console.log("[aisWebSocket open] Subscribe sended");
		// Хоть какая-то проверка актуальности целей AIS -- за отсутствием чего-то такого в SignalK
		checkDataFreshInterval = setInterval(function (){
			for(const vehicle in vehicles){
				if((!vehicles[vehicle].options.timestamp) || ((Date.now()-vehicles[vehicle].options.timestamp*1000)<aisFreshBefore)) continue;
				//console.log(vehicle,'протух в vehicles',Date.now()-vehicles[vehicle].options.timestamp*1000,aisFreshBefore);
				vehicles[vehicle].remove();
				vehicles[vehicle] = null;
				delete vehicles[vehicle];
			}
		},PosFreshBefore);
	}; // end aisWebSocket.onopen

	aisWebSocket.onmessage = function(event) {
		//console.log(`[aisWebSocket message] Данные AIS получены с сервера: ${event.data}`);
		let data;
		try{
			data = JSON.parse(event.data);
		}
		catch(error){
			console.log('aisWebSocket: Parsing inbound data',error.message);
			return;
		}
		if(!data.updates){	// handshaiking
			return;
		}
		if(data.context == `vessels.${vesselSelf}`) return;
		//console.log(vesselSelf,data);
		
		const vessel = data.context.substring(8);	// vessels.
		if(!AISdata[vessel]) AISdata[vessel] = {};
		//if(AISdata[vessel].shipname == 'Sample Ship Name') console.log('Before',JSON.stringify(AISdata[vessel]));
		//AISdata[vessel].mmsi = vessel.slice(vessel.lastIndexOf('mmsi')+5);
		for(let update of data.updates){
			for(let value of update.values){
				//console.log(data.context,value.path,value.value);
				//console.log(data.context,value);
				switch(value.path){
				case '':	// похоже, правильный путь - "", а не name, но тогда нет места для mmsi, ибо оно тоже по пути "". 
							// Но, видимо, по одному пути может быть много объектов?
							// Короче говоря, фактически name и mmsi -- это свойства, находящиеся по пути ""
							// При этом в подписку по "" попадают и communication и registrations
							// Это тоже объекты в ""?
					//console.log(data.context,value.value);
					//if(data.context == 'vessels.urn:mrn:imo:mmsi:201246757') console.log(data.context,value.value);
					for(const key in value.value){
						switch(key){
						case 'name':
							AISdata[vessel].shipname = value.value[key];
							break;
						case 'mmsi':
							AISdata[vessel].mmsi = value.value[key];
							break;
						case 'registrations':
							AISdata[vessel].imo = value.value[key].imo;
							break;
						case 'communication':
							//console.log(data.context,key,value.value[key]);
							if(value.value[key].callsignVhf) AISdata[vessel].callsign = value.value[key].callsignVhf;
							if(value.value[key].netAIS) AISdata[vessel].netAIS = value.value[key].netAIS;
							break;
						}
					}
					break;
				case 'name':
					AISdata[vessel].shipname = value.name;
					break;
				case 'mmsi':
					AISdata[vessel].mmsi = value.mmsi;
					break;
				case 'registrations.imo':
					AISdata[vessel].imo = value.imo;
					break;
				case 'communication.callsignVhf':
					AISdata[vessel].callsign = value.value;
					break;
				case 'communication.netAIS':
					AISdata[vessel].netAIS = value.value;
					break;
				case 'design.aisShipType':
					AISdata[vessel].shiptype = value.value.id;
					AISdata[vessel].shiptype_text = value.value.name;
					break;
				case 'design.draft':
					if(!isNaN(value.value.maximum)) AISdata[vessel].draught = value.value.maximum;
					else if(!isNaN(value.value.current)) AISdata[vessel].draught = value.value.current;
					break;
				case 'design.length':
					if(!isNaN(value.value.overall)) AISdata[vessel].length = value.value.overall;
					break;
				case 'design.beam':
					if(!isNaN(value.value)) AISdata[vessel].beam = value.value;
					break;
				case 'navigation.position':
					AISdata[vessel].lon = value.value.longitude;
					AISdata[vessel].lat = value.value.latitude;
					if(!AISdata[vessel].timestamp) AISdata[vessel].timestamp = Math.round(Date.parse(update.timestamp)/1000);	// преимущество у navigation.datetime
					break;
				case 'navigation.state':
					if(isNaN(value.value)) AISdata[vessel].status_text = value.value;
					else AISdata[vessel].status = value.value;
					break;
				case 'navigation.courseOverGroundTrue':
					if(!isNaN(value.value)) AISdata[vessel].course = Math.round(value.value*180/Math.PI);
					break;
				case 'navigation.headingTrue':
					if(!isNaN(value.value)) AISdata[vessel].heading = Math.round(value.value*180/Math.PI);
					break;
				case 'navigation.speedOverGround':
					if(!isNaN(value.value)) AISdata[vessel].speed = value.value;
					break;
				case 'navigation.destination.commonName':
					if(value.value) AISdata[vessel].destination = value.value;
					break;
				case 'navigation.destination.eta':
					if(value.value) AISdata[vessel].eta = value.value;
					break;
				case 'navigation.datetime':
					AISdata[vessel].timestamp = Math.round(Date.parse(value.value)/1000);
					break;
				}
			}
		}
		//if(AISdata[vessel].shipname == 'Sample Ship Name') {
		//	console.log('After',JSON.stringify(AISdata[vessel]));
		//	console.log();
		//}
		data = null;
		realtimeAISupdate(JSON.parse('{"class":"AIS","ais":'+JSON.stringify(AISdata)+'}'));	// хрен его знает где и почему портится AISdata, поэтому передаём "по значению".
		//realtimeAISupdate({"class":"AIS","ais":AISdata});	// 
	}; // end aisWebSocket.onmessage

	aisWebSocket.onclose = function(event) {
		console.log(`aisWebSocket closed: connection broken with code ${event.code} by reason ${event.reason}`);
		if(DisplayAISswitch.checked ) window.setTimeout(watchAISstart, 3000); 	// перезапустим сокет через  секунд, если в интерфейсе указано
		for(const vehicle in vehicles){
			vehicles[vehicle].remove();
			vehicles[vehicle] = null;
			delete vehicles[vehicle];
		}
		clearInterval(checkDataFreshInterval);	// остановить периодическую проверку свежести
	}; // end aisWebSocket.onclose

	aisWebSocket.onerror = function(error) {
	  console.log(`[aisWebSocket error] ${error.message}`);
	}; 	//end aisWebSocket.onerror

	function realtimeAISupdate(aisClass) {
	// Показывает цели AIS, перечисленные в aisClass.ais
	// те, которых там нет -- перестаёт показывать
	let aisData = aisClass.ais;
	//console.log(aisData); 	// массив с данными целей
	//console.log('',JSON.stringify(aisData));
	//console.log(DisplayAISswitch);
	let vehiclesVisible = [];
	const defaultSymbol = [0.8,0, -0.3,0.35, -0.3,-0.35]; 	// треугольник вправо, расстояния от центра, через которые нарисуют polyline
	const noHeadingSymbol = [0.35,0, 0,0.35, -0.35,0, 0,-0.35]; 	// ромбик
	const netAISdefaultSymbol = [1*0.5,0, 0.25*0.5,0.25*0.5, 0,1*0.5, -0.25*0.5,0.5*0.5, -1*0.5,0.75*0.5, -1*0.5,-0.75*0.5, -0.25*0.5,-0.5*0.5, 0,-1*0.5, 0.25*0.5,-0.25*0.5]; 	// треугольник, расстояния от центра, через которые нарисуют polyline
	const netAISnoHeadingSymbol = [1*0.35,0, 0.75*0.35,0.5*0.35, 1*0.35,1*0.35, 0.5*0.35,0.75*0.35, 0,1*0.35, -0.5*0.35,0.75*0.35, -1*0.35,1*0.35, -0.75*0.35,0.5*0.35, -1*0.35,0, -0.75*0.35,-0.5*0.35, -1*0.35,-1*0.35, -0.5*0.35,-0.75*0.35, 0,-1*0.35, 0.5*0.35,-0.75*0.35, 1*0.35,-1*0.35, 0.75*0.35,-0.5*0.35]; 	// ромбик: правый, верхний, левый, нижний ПРотив часовой от правого?
	for(const vehicle in aisData){
		//console.log(vehicle,aisData[vehicle]);
		if(vehicle.toLowerCase() == 'error') break;
		//console.log(aisData[vehicle].lat,aisData[vehicle].lon);
		if((aisData[vehicle].lat === null) || (aisData[vehicle].lon === null) || (aisData[vehicle].lat === undefined) || (aisData[vehicle].lon === undefined)) continue;	// не показываем цели без координат
		//console.log(vehicles);
		if(!vehicles[vehicle]) { 	// global var, массив layers с целями
			//console.log('Create layers',vehicle,aisData[vehicle]);
			vehicles[vehicle] = L.trackSymbol(L.latLng(0,0),{
				trackId: vehicle,
				leaderTime: velocityVectorLengthInMn*60,
				fill: true,
				fillOpacity: 1.0,
				stroke: true,
				opacity: 1.0,
				weight: 1.0,
			}).addTo(map);
		}
		// Значёк будем переприсваивать каждый раз, потому что в SignalK неизвестно, когда придёт
		// признак aisData[vehicle].netAIS
		if(aisData[vehicle].netAIS) { 	// цель получена от netAIS
			vehicles[vehicle].setDefaultSymbol(netAISdefaultSymbol);
			vehicles[vehicle].setNoHeadingSymbol(netAISnoHeadingSymbol);
		}
		else { 	// цель получена от локального приёмника AIS
			vehicles[vehicle].setDefaultSymbol(defaultSymbol);
			vehicles[vehicle].setNoHeadingSymbol(noHeadingSymbol);
		}
		//console.log(vehicles[vehicle]);
		vehicles[vehicle].addData(aisData[vehicle]); 	// обновим данные		
		vehiclesVisible.push(vehicle); 	// запомним, какие есть
	}
	for(const vehicle in vehicles){
		if(vehiclesVisible.includes(vehicle) && DisplayAISswitch.checked) continue; 	// типа, синхронизация... clearInterval -- асинхронная функция, и может не успеть отключить опрос AIS до того, как цели будут убраны с экрана. Тогда они уберутся здесь.
		vehicles[vehicle].remove();
		vehicles[vehicle] = null;
		delete vehicles[vehicle];
	}
	} // end function realtimeAISupdate

return aisWebSocket
} // end function watchAISstart

watchAISstart(); 	// запускам периодическую функцию смотреть AIS
DisplayAISswitch.checked = true;

function watchAISstop(message=''){
console.log('AIS switched OFF');
aisWebSocket.close(1000,message);
for(const vehicle in vehicles){
	vehicles[vehicle].remove();
	vehicles[vehicle] = null;
	delete vehicles[vehicle];
}
} // end function watchAISstop

function watchAISswitching(){
if(DisplayAISswitch.checked) watchAISstart();
else watchAISstop('Dispalying AIS stopped');
}; // end function watchAISswitching




// 	Запуск периодических функций	 realtime -- в galadrielmap.js, функция, асинхронно обращающаяся к uri

// Динамическое обновление показываемых маршрутов
var updateRoutesInterval = setInterval(realtime,2000,updateRouteServerURI,routeUpdate);	//

function routeUpdate(changedRouteNames) {
// Вызывается из-под realtime 
//console.log('changedRouteNames',changedRouteNames);
if(routeDisplayed.innerHTML.trim() == "") { 	// не показывается ни одного маршрута
	updateRoutesInterval = clearInterval(updateRoutesInterval); 	// прекратим следить за изменениями
	routeDisplayed.addEventListener("DOMNodeInserted", function (event) { 	// добавим обработчик события изменения DOM
		if(! updateRoutesInterval) { 	// никогда не должно быть здесь updateRoutesInterval, но оно может не успеть
			updateRoutesInterval = setInterval(function(){realtime(updateRouteServerURI,routeUpdate);},2000); 	// запустим слежение за изменением показываемых маршрутов
		}
		routeDisplayed.removeEventListener("DOMNodeInserted", this); 	// удаляем обработчик
	}
	, false);
	return;
}
// в связи с возможностью наличия в trackDisplayed дублирующихся id --
// может быть, вместо document.getElementById(name) сделать цикл по потомкам routeDisplayed? 
let node;
for(const name of changedRouteNames){
	node = document.getElementById(name); 	// однако, в trackDisplayed могут быть те же имена. Забить? в querySelector требуется экранирование пробелов и спец-символов. Это секс.
	if(node.parentNode != routeDisplayed) continue; 	// элемент, конечно, всегда есть, нужно, чтобы он показывался
	//console.log(node);
	savedLayers[name].remove(); 	// удалим слой с карты
	savedLayers[name] = null; 	// удалим сам слой
	displayRoute(node); 	// перересуем маршрут
}
} // end  function routeUpdate

// Текущий трек
// Должен обновляться, даже если обновлялка не описана в конфиге, потому что трек может писать кто-то ещё. 
// Т.е. в худшем случае -- мы не знаем, обновляется ли currentTrack, или нет
var currentTrackUpdateProcess = setInterval(currentTrackUpdate,3000);
//console.log('Запущено слежение за логом, currentTrackUpdateProcess=', currentTrackUpdateProcess);
function currentTrackUpdate(){
// Global: map, savedLayers, currentTrackName, currentTrackShowedFlag
// DOM objects: currTrackSwitch, loggingSwitch, trackDisplayed
//console.log('currentTrackName='+currentTrackName,'currentTrackShowedFlag=',currentTrackShowedFlag);
//console.log(trackDisplayed.querySelector('li[title="Current track"]'));

// имеется имя текущего трека, и в интерфейсе указано показывать текущий трек, или текущий трек в списке показываемых
if((currentTrackName && currTrackSwitch.checked)||trackDisplayed.querySelector('li[title="Current track"]')) { 	
	if(currentTrackShowedFlag !== false) { 	// Текущий трек некогда был загружен или сейчас загружается
		if(map.hasLayer(savedLayers[currentTrackName])) { 	// если он реально есть
			if(typeof loggingSwitch === 'undefined'){ 	// обновлялка не сконфигурирована
				updateCurrTrack(); 	//  - обновим,  galadrielmap.js
			}
			else {
				if(loggingSwitch) updateCurrTrack(); 	//  - обновим  galadrielmap.js
			}
			currentTrackShowedFlag = true;
		}
		else { 
			if(currentTrackShowedFlag != 'loading') currentTrackShowedFlag = false;
		}
	}
	else { 	// текущий трек ещё не был загружен
		//console.log(document.getElementById(currentTrackName));
		//console.log(tracks.querySelector('li[title="Current Track"]'));
		currentTrackShowedFlag = 'loading'; 	// укажем, что трек сейчас загружается
		selectTrack(document.getElementById(currentTrackName),trackList,trackDisplayed,displayTrack); 	// загрузим трек асинхронно. galadrielmap.js
	}
}
} // end function currentTrackUpdate


// Сохранение переменных
var savePositionProcess = setInterval(doSavePosition,savePositionEvery); 	// велим сохранять всё каждые savePositionEvery
// Всегда после загрузки страницы "Следовать за курсором" включено
document.getElementById("followSwitch").checked = true; 	// выставим переключатель на панели Настроек в правильное положение
</script>
</html>
