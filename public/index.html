<!DOCTYPE html >
<html lang="ru">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta http-equiv="Content-Script-Type" content="text/javascript">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" > <!--  tell the mobile browser to disable unwanted scaling of the page and set it to its actual size -->

	<script src="internationalisation/internationalisation.js"></script> <!-- там определяются переменные, используемые в загружаемых скриптах -->
    <!-- Leaflet -->
	<link rel="stylesheet" href="leaflet/leaflet.css" type="text/css">
	<script src="leaflet/leaflet.js"></script>
    <script src="Leaflet.RotatedMarker/leaflet.rotatedMarker.js"></script>
    <!-- Leaflet sidebar -->
    <link rel="stylesheet" href="leaflet-sidebar-v2/css/leaflet-sidebar.min.css" />
	<script src="leaflet-sidebar-v2/js/leaflet-sidebar.min.js"></script>

	<script src="polycolor/polycolorRenderer.js"></script>
	<script src="value2color/value2color.js"></script>

	<link rel="stylesheet" href="leaflet-omnivorePATCHED/leaflet-omnivore.css" />
	<script src="leaflet-omnivorePATCHED/leaflet-omnivore.js"></script>
	<script src="Leaflet.Editable/src/Leaflet.Editable.js"></script>

	<link rel="stylesheet" href="leaflet-measure-path/leaflet-measure-path.css" />
	<script src="leaflet-measure-path/leaflet-measure-path.js"></script>

    <script src="L.TileLayer.Mercator/src/L.TileLayer.Mercator.js"></script>
	<script src='supercluster/supercluster.js'></script>
	<script src="leaflet-tracksymbolPATCHED/leaflet-tracksymbol.js"></script>

	<script src="coordinate-parserPATCHED/coordinates.js">	</script>
	<script src="coordinate-parserPATCHED/validator.js"></script>
	<script src="coordinate-parserPATCHED/coordinate-number.js"></script> 
	
	<link rel="stylesheet" href="galadrielmap.css" type="text/css"> <!-- замена стилей -->
	<script src="galadrielmap.js"></script>
	<script src="options.js"></script>
   <title>GaladrielMap SignalK ed.</title>
   <!-- карта на весь экран -->
   <style>
body {
    padding: 0;
    margin: 0;
}
html, body, #mapid {
    height: 100%;
    width: 100vw;
}
   </style>
</head>
<body>
<div id="sidebar" class="leaflet-sidebar collapsed">
	<!-- Nav tabs -->
	<div class="leaflet-sidebar-tabs">
		<ul role="tablist" id="featuresList">
			<li id="homeTab"><a href="#home" role="tab"><img src="img/maps.svg" alt="menu" width="70%"></a></li>
			<li id="dashboardTab"><a href="#dashboard" role="tab"><img src="img/speed1.svg" alt="dashboard" width="70%"></a></li>
			<li id="tracksTab"><a href="#tracks" role="tab"><img src="img/track.svg" alt="tracks" width="70%" OnClick='loggingCheck();'></a></li>
			<li id="measureTab" ><a href="#measure" role="tab"><img src="img/route.svg" alt="Create route" width="70%"></a></li>
			<li id="routesTab"><a href="#routes" role="tab"><img src="img/poi.svg" alt="Routes and POI" width="70%"></a></li>
		</ul>
		<ul role="tablist" id="settingsList">
			<li id="MOBtab"><a href="#MOB" role="tab"><img src="img/mob.svg" alt="activate MOB" width="70%"></a></li>
			<li><a href="#settings" role="tab"><img src="img/settings1.svg" alt="settings" width="70%"></a></li>
		</ul>
	</div>
	<!-- Tab panes -->
	<div class="leaflet-sidebar-content" id='tabPanes'>
<!--
<div id='infoBox' style='font-size: 90%; position: absolute;'>
</div>
<script>
infoBox.innerText='width: '+window.outerWidth+' height: '+window.outerHeight;
</script>
-->
		<!-- Карты -->
		<div class="leaflet-sidebar-pane" id="home">
			<h1 class="leaflet-sidebar-header leaflet-sidebar-close"> <span id="homeHeaderTXT"></span> <span class="leaflet-sidebar-close-icn"><img src="img/Triangle-left.svg" alt="close" width="16px"></span></h1>
			<br>
			<ul id="mapDisplayed" class='commonList'>
			</ul>
			<ul id="mapList" class='commonList'>
					<li hiden class="template" onClick="{selectMap(event.currentTarget)}"></li>
			</ul>
		</div>
		<!-- Приборы -->
		<div class="leaflet-sidebar-pane" id="dashboard" style="height:100%;">
			<h1 class="leaflet-sidebar-header leaflet-sidebar-close"> <span id="dashboardHeaderTXT"></span> <span class="leaflet-sidebar-close-icn"><img src="img/Triangle-left.svg" alt="close" width="16px"></span></h1>
			<div class="big_symbol"> <!-- передвинуть карту на место курсора -->
				<div>
					<div style="line-height:0.6;" onClick="map.setView(cursor.getLatLng());">				
						<div style="font-size:50%;"><span id="dashboardSpeedTXT"></span></div><br>
						<div id='velocityDial'></div><br>
						<div style="font-size:50%;"><span id="dashboardSpeedMesTXT"></span></div>
					</div>
					<div id='depthDial' style="line-height:0.4;" onClick="map.setView(cursor.getLatLng());">				
					</div>
					<div style="line-height:0.6;" onClick="map.setView(cursor.getLatLng());">
						<br><span style="font-size:50%;"><span id="dashboardCourseTXT"></span></span>
						<span style="font-size:30%; "><br><span id="dashboardCourseAltTXT"></span></span>
					</div>
					<div style="">
						<span id='courseDisplay'></span>
					</div>
					<div style="font-size:50%;line-height:0.6;" onClick="doCopyToClipboard(lat+' '+lng);" >
						<br><span style="font-size:50%;" id="mobPosTXT"></span><br>
						<span style="font-size:30%;" id="mobPosAltTXT"></span>
					</div>
					<div style="font-size:50%;" onClick="doCopyToClipboard(lat+' '+lng);">
						<span id='locationDisplay'></span>
					</div>
				</div>
			</div>
			<div id="positionTimeDisplay" style="float:left;position:relative;bottom:90%;left:-1rem;"></div>
			<div class="scaledText" style="text-align:center; position: absolute; bottom: 0;">
				<span id="dashboardSpeedZoomTXT"></span> <span id='velocityVectorLengthInMnDisplay'></span> <span id="dashboardSpeedZoomMesTXT"></span>.
			</div>
		</div>
		<!-- Треки -->
		<div class="leaflet-sidebar-pane" id="tracks">
			<h1 class="leaflet-sidebar-header leaflet-sidebar-close"> <span id="tracksHeaderTXT"></span> <span class="leaflet-sidebar-close-icn"><img src="img/Triangle-left.svg" alt="close" width="16px"></span></h1>
			<div style="margin: 1rem;">
				<div class="onoffswitch" style="float:right;margin: 1rem auto;"> 
					<input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="loggingSwitch" onChange="loggingRun();" >
					<label class="onoffswitch-label" for="loggingSwitch">
						<span class="onoffswitch-inner"></span>
						<span class="onoffswitch-switch"></span>
					</label>
				</div>
				<div style="padding:1rem 0 0 0;font-size:120%">
					<span id="loggingIndicator" style="font-size:100%;"></span> <span id="loggingTXT"></span>
				</div>
			</div>
			<ul id="trackDisplayed" class='commonList'>
			</ul>
			<ul id="trackList" class='commonList'>
				<li hidden class="template" onClick='{selectTrack(event.currentTarget,trackList,trackDisplayed,displayTrack)}' class='currentTrackName' title=''></li>
			</ul>
		</div>
		<!-- Расстояния -->
		<div class="leaflet-sidebar-pane" id="measure">
			<h1 class="leaflet-sidebar-header leaflet-sidebar-close"> <span id="measureHeaderTXT"></span> <span class="leaflet-sidebar-close-icn"><img src="img/Triangle-left.svg" alt="close" width="16px"></span></h1>
			<!-- Кнопки создания/редактирования маршрута -->
			<div id='routeControls' class="routeControls" style="width:95%; padding:1rem 0 2rem; text-align: center;">
				<input type="radio" name="routeControl" class='L' id="routeCreateButton"
					onChange="
						pointsControlsDisable();	// отключить кнопки точек
						if(!currentRoute) currentRoute = dravingLines; 	// 
						//console.log('[Кнопка Начать] currentRoute:',currentRoute._leaflet_id,'dravingLines:',dravingLines._leaflet_id);
						let layer = map.editTools.startPolyline(false,drivedPolyLineOptions.options);
						layer.options.color = '#FDFF00';
						layer.feature = drivedPolyLineOptions.feature;
						layer.on('editable:editing', function (event){event.target.updateMeasurements();});	// обновлять расстояния при редактировании
						//layer.on('click', L.DomEvent.stop).on('click', tooggleEditRoute);
						layer.on('click',tooggleEditRoute);
						layer.addTo(currentRoute);
						routeEraseButton.disabled=false;
						//if(!routeSaveName.value || Date.parse(routeSaveName.value)) routeSaveName.value = new Date().toJSON(); 	// запишем в поле ввода имени дату, если там ничего не было или была дата
						if(!routeSaveName.value) routeSaveName.value = new Date().toJSON(); 	// запишем в поле ввода имени дату, если там ничего не было
						//console.log('[Кнопка Начать] layer:',layer);
					"
				>
				<label for="routeCreateButton"><span id="routeControlsBeginTXT"></span></label>
				<input type="radio" name="routeControl" class='R' id="routeContinueButton"
					onChange="
						// по нажатию кнопки создаётся однократно срабатываемый обработчик клика
						// на вершине объекта editable
						map.once('editable:vertex:click', function f(e) { // это CancelableVertexEvent
	                        //console.log(e);
	                        //console.log(e.vertex);
	                        e.cancel(); 	// прекратить дальнейшую обработку
	                        //e.vertex.split();
							e.vertex.continue();
							routeCreateButton.checked=true;
						});
					"
				>
				<label for="routeContinueButton"><span id="routeControlsContinueTXT"></span></label><br>
				<div id='pointsButtons'>
					<br>
					<button id='ButtonSetpoint' onClick='createEditableMarker(pointIcon);' class='pointButton'><img src="leaflet-omnivorePATCHED/symbols/point.png" alt="ok" width="100%"></button>
					<button id='ButtonSetanchor' onClick='createEditableMarker(anchorIcon);' class='pointButton'><img src="leaflet-omnivorePATCHED/symbols/anchor.png" alt="ok" width="100%"></button>
					<button id='ButtonSetcaution' onClick='createEditableMarker(cautionIcon);' class='pointButton'><img src="leaflet-omnivorePATCHED/symbols/caution.png" alt="ok" width="100%"></button><br>
					<br>
				</div>
				<input id = 'editableObjectName' type="text" title="" placeholder='' size='255' style='width:90%;font-size:150%;'><br>
				<textarea id = 'editableObjectDescr' title="" rows='3' cols='255' placeholder='' style='width:87%;padding: 0.5rem 3%;'></textarea><br>
				<br>
				<input type="radio" name="routeControl" id="routeEraseButton"
					onChange="
						delShapes(true);	// удалим все редактируемые объекты
						routeControlsDeSelect();	// сделаем невыбранными кнопки управления рисованием маршрута
						routeCreateButton.disabled=false; 	// - сделать доступной кнопку Начать
						pointsControlsEnable();	// включим кнопки точек
						this.disabled=true;
						routeContinueButton.disabled=true;
						// раз не осталось редактируемых объектов, редактирование завершено? Сохраним.
						if(currentRoute==dravingLines)	doSaveMeasuredPaths();
						//else saveGPX();	// ?но загруженный файл не будем сохранять, потому что он тогда перезагрузится, и перестанет быть текущим редактируемым
						//currentRoute = null;	// ?не будем считать, что редактирование завершено
					"
				>
				<label for="routeEraseButton"><span id="routeControlsClearTXT"></span></label>
			</div>
			<!-- Поиск места -->
			<div style="width:95%;">
				<div style="margin:0;padding:0;">
					<button onClick='goToPositionField.value += "°";goToPositionField.focus();' style="width:2rem;height:1.5rem;margin:0 0.7rem 0 0;"><span style="font-weight: bold; font-size:150%;">°</span></button>
					<button onClick='goToPositionField.value += "′";goToPositionField.focus();' style="width:2rem;height:1.5rem;margin:0 0.7rem 0 0;"><span style="font-weight: bold; font-size:150%;">′</span></button>
					<button onClick='goToPositionField.value += "″";goToPositionField.focus();' style="width:2rem;height:1.5rem;margin:0 0rem 0 0;"><span style="font-weight: bold; font-size:150%;">″</span></button><br>
				</div>
				<span id="routePosTXT"></span><br>
				<input id = 'goToPositionField' type="text" title="" size='12' style='width:11rem;font-size:150%;'>			
				<button id = 'goToPositionButton' onClick='flyByString(this.value);' style="width:3rem;padding:0.2rem;float:right;"><img src="img/ok.svg" alt="Ok" width="16px"></button><br>
			</div>
			<div  style='width:98%;height:12rem;overflow:auto;margin:0.3rem 0;'>
				<ul id='geocodedList' class='commonList'>
				</ul>
			</div>
			<!-- Сохранение маршрута -->
			<div style="width:95%; padding: 1rem 0; text-align: center;">
				<h3 id="routeSaveTitle"></h3>
				<input id = 'routeSaveName' type="text" title="" placeholder='' size='255' style='width:95%;font-size:150%;'>
				<textarea id = 'routeSaveDescr' title="" rows='5' cols='255' placeholder='' style='width:93%;padding: 0.5rem 3%;'></textarea>
				<button onClick="
					saveGPX();
					currentRoute = null;
					routeSaveName.value = '';
					routeSaveDescr.value = '';" 
				" type='submit'  class='okButton' style="float:right;"><img src="img/ok.svg" alt="Ok" width="16px"></button>
				<button onClick='routeSaveName.value=""; routeSaveDescr.value="";' type='reset' class='okButton' style="float:left;"><img src="img/no.svg" alt="clear" width="16px"></button>
				<div id='routeSaveMessage' style='margin: 1rem;'></div>
			</div>			
		</div>
		<!-- Места и маршруты -->
		<div class="leaflet-sidebar-pane" id="routes">
			<h1 class="leaflet-sidebar-header leaflet-sidebar-close"> <span id="routesHeaderTXT"></span> <span class="leaflet-sidebar-close-icn"><img src="img/Triangle-left.svg" alt="close" width="16px"></span></h1>
			<ul id="routeDisplayed" class='commonList'>
			</ul>
			<ul id="routeList" class='commonList'>
				<li hiden class="template" onClick='{selectTrack(event.currentTarget,routeList,routeDisplayed,displayRoute)}'></li>
			</ul>
		</div>
		<!-- MOB -->
		<div class="leaflet-sidebar-pane" style="height:90%;" id="MOB">
			<h1 class="leaflet-sidebar-header leaflet-sidebar-close" style="background-color:red;"><span id="mobTXT"></span><span class="leaflet-sidebar-close-icn"><img src="img/Triangle-left.svg" alt="close" width="16px"></span></h1>
			<div style="margin: 1rem 1rem;width:90%;text-align: center;">
				<button onClick='MOBalarm();' style="width:75%;"><span style=""><span id="addMarkerTXT"></span></span></button>
			</div>
			<div class="big_symbol" style="line-height: normal;align-items: center;height:70%;" onClick="map.setView(currentMOBmarker.getLatLng());"> <!--  передвинуть карту на место текущего маркера MOB -->
				<div style=''><!-- объемлющий div необходим -->
						<div style="font-size:50%;">
							<span style="font-size:50%;display:block;" id="bearingTXT"></span>
							<span style="font-size:40%;display:block;" id="altBearingTXT"></span>
							<span style="margin:0.5rem;display:block;" id='azimuthMOBdisplay'> </span>
						</div>
						<div style="font-size:75%;margin:1rem 0;">
							<span style="font-size:40%;display:block;"><span id="distanceTXT"></span>, <span id="dashboardMeterMesTXT"></span></span>
							<span style="font-size:30%;display:block;" id="altDistanceTXT"></span>
							<span style="margin:0.5rem;display:block;" id='distanceMOBdisplay'> </span>
							<span style="font-size:75%;margin:0.5rem;display:block;" id='directionMOBdisplay'></span>
						</div>
						<div style="font-size:50%;" onClick="doCopyToClipboard(Math.round(currentMOBmarker.getLatLng().lat*10000)/10000+' '+Math.round(currentMOBmarker.getLatLng().lng*10000)/10000);" >
							<span style="font-size:50%;display:block;" id="dashboardPosTXT"></span>
							<span style="font-size:40%;display:block;" id="dashboardPosAltTXT"></span>
							<span style="margin:0.3rem;display:block;" id='locationMOBdisplay'></span>
						</div>
				</div>
			</div>
			<div style="position: absolute; bottom: 1rem;width:90%;text-align: center;"> <!-- Отбой -->
				<button onClick='delMOBmarker();' id='delMOBmarkerButton' style="width:80%;margin:1rem 0;font-size:75%;" disabled ><span style="" id="removeMarkerTXT"></span></button>
				<div>
				<a style="position:relative;left:-1rem;font-size:100%;color:gray;" onClick='
					this.nextElementSibling.disabled=false;
					this.style.color="green";
				'>&#x2B24;</a>
				<button onClick='MOBclose();' style="width:75%;" disabled><span style="" id="cancelMOBTXT"></span></button>
				</div>
			</div>
		</div>
		<!-- Настройки -->
		<div class="leaflet-sidebar-pane" id="settings">
			<h1 class="leaflet-sidebar-header leaflet-sidebar-close"><span id="settingsHeaderTXT"></span> <span class="leaflet-sidebar-close-icn"><img src="img/Triangle-left.svg" alt="close" width="16px"></span></h1>
			<div style="margin: 1rem 1rem;"> <!-- Следование за курсором -->
				<div class="onoffswitch" style="float:right;margin: 1rem auto;"> <!--  Переключатель https://proto.io/freebies/onoff/  -->
					<input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="followSwitch" onChange="noFollowToCursor=!noFollowToCursor; CurrnoFollowToCursor=noFollowToCursor;" checked>
					<label class="onoffswitch-label" for="followSwitch">
						<span class="onoffswitch-inner"></span>
						<span class="onoffswitch-switch"></span>
					</label>
				</div>
				<span style="font-size:120%" id="settingsCursorTXT"></span>
			</div>
			<div style="margin: 1rem 1rem;"> <!-- Текущий трек всегда показывается -->
				<div class="onoffswitch" style="float:right;margin: 1rem auto;"> <!--  Переключатель https://proto.io/freebies/onoff/  -->
					<input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="currTrackSwitch" onChange="if(this.checked) startCurrentTrackUpdate(); else stopCurrentTrackUpdate();" checked>
					<label class="onoffswitch-label" for="currTrackSwitch">
						<span class="onoffswitch-inner"></span>
						<span class="onoffswitch-switch"></span>
					</label>
				</div>
				<span style="font-size:120%" id="settingsTrackTXT"></span>
			</div>
			<div style="margin: 1rem 1rem;"> <!-- Выбранные маршруты всегда показываются -->
				<div class="onoffswitch" style="float:right;margin: 1rem auto;"> <!--  Переключатель https://proto.io/freebies/onoff/  -->
					<input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="SelectedRoutesSwitch" onChange="">
					<label class="onoffswitch-label" for="SelectedRoutesSwitch">
						<span class="onoffswitch-inner"></span>
						<span class="onoffswitch-switch"></span>
					</label>
				</div>
				<span style="font-size:120%" id="settingsRoutesAlwaysTXT"></span>
			</div>
			<div style="margin: 1rem 1rem;"> <!-- Показывать окружности дистанции -->
				<div class="onoffswitch" style="float:right;margin: 1rem auto;"> <!--  Переключатель https://proto.io/freebies/onoff/  -->
					<input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="distCirclesSwitch" onChange="distCirclesToggler();">
					<label class="onoffswitch-label" for="distCirclesSwitch">
						<span class="onoffswitch-inner"></span>
						<span class="onoffswitch-switch"></span>
					</label>
				</div>
				<span style="font-size:120%" id="settingsdistCirclesTXT"></span>
			</div>
			<br><br>
			<div style="margin: 1rem 1rem;"> <!-- Показ целей AIS -->
				<div class="onoffswitch" style="float:right;margin: 0 auto;"> <!--  Переключатель https://proto.io/freebies/onoff/  -->
					<input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="DisplayAISswitch" onChange="watchAISswitching();">
					<label class="onoffswitch-label" for="DisplayAISswitch">
						<span class="onoffswitch-inner"></span>
						<span class="onoffswitch-switch"></span>
					</label>
				</div>
				<span style="font-size:120%;vertical-align:middle;" id="DisplayAIS_TXT"></span>
			</div>
			<br><br>
			<div style="margin: 1rem 1rem;"> <!-- максимальная скорость обновления -->
				<div style="float:right;margin: 1rem auto;">
					<input id='minWATCHintervalInput' type="text" pattern="[0-9]*" title="" size='4' style='width:3rem;font-size:175%;'
					 onChange="minWATCHinterval=parseFloat(this.value);
					 if(isNaN(minWATCHinterval)) minWATCHinterval=0;
					 //console.log('Изменение, minWATCHinterval',minWATCHinterval);
					 spatialWebSocketStop('Close socket to change WATCH interval');
					 watchAISstop('Close socket to change WATCH interval');
					"
					>
				</div>
				<span style="font-size:120%;vertical-align:middle;" id="minWATCHintervalTXT"></span>
			</div>
		</div>
	</div>
</div>
<div id="mapid" ></div>
</body>

<script> "use strict";
// Карта
var defaultMap = 'world-coastline'; 	// chart-plugin identifier Карта, которая показывается, если нечего показывать. Народ интеллектуальный ценз ниасилил.
var savedLayers = []; 	// массив для хранения объектов, когда они не на карте
var additionalTileCachePath = ''; 	// дополнительный кусок пути к тайлам между именем карты и /z/x/y.png Используется в версионном кеше, например, в погоде. Без / в конце, но с / в начале, либо пусто. Присваивается в javascriptOpen в параметрах карты. Или ещё где-нибудь.
var startCenter = JSON.parse(getCookie('GaladrielMapPosition')); 	// getCookie from galadrielmap.js
if(! startCenter) startCenter = L.latLng([55.754,37.62]); 	// начальная точка
var startZoom = JSON.parse(getCookie('GaladrielMapZoom')); 	// getCookie from galadrielmap.js
if(! startZoom) startZoom = 12; 	// начальный масштаб
var userMoveMap = true; 	// флаг для отделения собственных движений карты от пользовательских. Считаем все пользовательскими, и только где надо - выставляем иначе
// ГПС
var minWATCHinterval=JSON.parse(getCookie('GaladrielminWATCHinterval'));	// Минимальный интервал, сек., с которым будут приходить данные от gpsdPROXY. Если 0 -- то по мере их получения от датчиков
if(!minWATCHinterval) minWATCHinterval = 0;
minWATCHintervalInput.value = minWATCHinterval;
if(PosFreshBefore < (2*minWATCHinterval*1000+1000)) PosFreshBefore = 2*minWATCHinterval*1000+1000;	// PosFreshBefore в options.js
if(DepthFreshBefore < (2*minWATCHinterval*1000)) DepthFreshBefore = 2*minWATCHinterval*1000;	// DepthFreshBefore в options.js
var followToCursor = true; 	// карта следует за курсором Обеспечивает только паузу следования при перемещениях и масштабировании карты руками
var noFollowToCursor = false; 	// карта никогда не следует за курсором Глобальное отключение следования. Само не восстанавливается.
var CurrnoFollowToCursor = 1; 	// глобальная переменная для сохранения состояния
var followPause = 10 * 1000; 	// пауза следования карты за курсором, когда карту подвинули руками, микросекунд
var savePositionEvery = 15 * 1000; 	// будем сохранять положение каждые микросекунд локально в куку
var followPaused; 	// объект таймера, который восстанавливает следование курсору
if(!velocityVectorLengthInMn) velocityVectorLengthInMn = 10; 	// длинной в сколько минут пути рисуется линия скорости
// Окружности дистанции
if(getCookie('GaladrielMapdistCirclesSwitch') == undefined) distCirclesSwitch.checked = true; 	// показывать окружности дистанции
else distCirclesSwitch.checked = Boolean(+getCookie('GaladrielMapdistCirclesSwitch')); 	// getCookie from galadrielmap.js
// AIS
var vehicles = []; 	// list of visible by AIS data vehicle objects массив layers с целями
// Пути и маршруты
var editorEnabled = false;	// семафор, что можно использовать редактирования
// Путь
var currentTrackServerURI = 'getlasttrkpt'; 	// адрес для подключения к сервису, отдающему сегменты текущего трека
var trackDirURI = 'track'; 	// адрес каталога с треками
var routeDirURI = 'route'; 	// адрес каталога с маршрутами
var currentTrackName = ''; 	// имя текущего (пишущегося сейчас) трека
var updateRouteServerURI = 'checkRoutes'; 	// url службы динамического обновления маршрутов
if(getCookie('GaladrielcurrTrackSwitch') == undefined) currTrackSwitch.checked = true; 	// показывать текущий трек вместе с курсором
else currTrackSwitch.checked = Boolean(+getCookie('GaladrielcurrTrackSwitch')); 	// getCookie from galadrielmap.js
if(getCookie('GaladrielSelectedRoutesSwitch') == undefined) SelectedRoutesSwitch.checked = false; 	// показывать выбранные маршруты
else SelectedRoutesSwitch.checked = Boolean(+getCookie('GaladrielSelectedRoutesSwitch')); 	// getCookie from galadrielmap.js
loggingSwitch.checked = Boolean(+getCookie('GaladrielloggingSwitch')); 	// getCookie from galadrielmap.js
if(loggingSwitch.checked) loggingRun();	// запустим запись трека, если было указано запустить
var currentRoute; 	// объект Editable, по которому щёлкнули. Типа, текущий.
var globalCurrentColor = 0xFFFFFF; 	// цвет линий и  значков кластеров после первого набора
var currentTrackShowedFlag = false; 	// флаг, не показывается ли текущий путь. Если об этом спрашивать у Leaflet, то пока загружается трек, можно запустить его загрузку ещё раз пять.
// Маршрут
var drivedPolyLineOptions;
var currentRoute; 	// L.layerGroup, по объекту Editable которого щёлкнули. Типа, текущий.
{let weight;
if(L.Browser.mobile && L.Browser.touch) weight = 10; 	// мобильный браузер
else weight = 7; 	// стационарный браузер
drivedPolyLineOptions = { options: {
		showMeasurements: true,	// включить показ расстояний
		//color: '#FDFF00',
		weight: weight,
		opacity: 0.5,
	},
	feature: {type: 'Feature',
		properties: { 	// типа, оно будет JSONLayer
			isRoute: true 	// укажем, что это путь
		},
	},
};
}
var dravingLines = L.layerGroup();	// слои, в которых, собственно, рисуются маршруты и путевые точки
dravingLines.properties = {};
var goToPositionManualFlag = false; 	// флаг, что поле goToPositionField стали редактировать руками, и его не надо обновлять

// Dashboard
var lat; 	 	// широта
var lng; 	 	// долгота, округлённые до 4-х знаков

// MOB
var currentMOBmarker;
// main output data
var upData = {};
var vesselSelf;
var instanceSelf = getCookie('GaladrielMapInstance');	// идентификатор экземпляра программы
if(!instanceSelf) {
	instanceSelf = generateUUID();
	let expires =  new Date();
	expires.setTime(expires.getTime() + (60*24*60*60*1000)); 	// протухнет через два месяца
	document.cookie = "GaladrielMapInstance="+instanceSelf+"; expires="+expires+"; path=/; SameSite=Lax;";
}
var collisionVessels = {};	///////// for collision test purpose /////////


// подготовка интерфейса, списков карт и треков, etc.
onBodyLoad()	

// Определим карту
var map = L.map('mapid', {
	center: startCenter,
    zoom: startZoom,
    attributionControl: false,
    zoomControl: false,
    editable: true
	}
);

// Controls
// Zoom в правом верхнем углу
L.control.zoom({
     position:'topright'
}).addTo(map);

// Версия и пр. в правом нижнем углу
var info = L.control.attribution({
	prefix: '<a href="https://youtu.be/kwMt4rjgsJs"  target=”_blank”><i>имевший цель, но чуждый смысла</i></a>'
}).addTo(map);

// Шкала масштаба
L.control.scale({
	position: 'bottomleft',
	maxWidth: 200,
	imperial: false
}
).addTo(map);

// control для записывания в clipboard
var copyToClipboard = new L.Control.CopyToClipboard({ 	// класс определён в galadrielmap.js
	position: 'bottomright'
}); 	// на карту не добавляется


// Панель управления
var sidebar = L.control.sidebar('sidebar',{
	container: 'sidebar',
}).addTo(map);
sidebar.on("content", function(event){ 	// Событие открытия? панели 
	//alert(event.id);
	switch(event.id){ 	// какую вкладку открыли
	case 'measure': 	// рисование маршрута
		centerMarkOn(); 	// включить крестик в середине
		if(CurrnoFollowToCursor === 1)CurrnoFollowToCursor = noFollowToCursor;  // запомним состояние глобального признака следования за курсором, если ещё не запоминали
		noFollowToCursor = true; 	// отключим следование за курсором
		editorEnabled = true;	// разрешим редактирования
		routeCreateButton.disabled=false; 	// - сделать доступной кнопку Начать
		pointsControlsEnable();	// включим кнопки точек
		break;
	case 'MOB': 	// человек за бортом
		if(!map.hasLayer(mobMarker)) MOBalarm();
		else if(!map.hasLayer(cursor)) centerMarkOn(); 	// включить крестик в середине
		break;
	}
});
sidebar.on("closing", function(){
	if(CurrnoFollowToCursor !== 1) noFollowToCursor = CurrnoFollowToCursor; 	// восстановим признак следования за курсором
	CurrnoFollowToCursor = 1;
	centerMarkOff(); 	// выключить крестик посередине
	if(currentRoute && delShapes()) editorEnabled='maybe';	// есть редактируемые слои
	else {
		editorEnabled=false; 	// если нет редактируемых слоёв -- запретим включать редактирования
		currentRoute = null;
		routeSaveName.value = '';
		routeSaveDescr.value = '';
	}
});
// end controls
// Поведение карты
map.on('movestart zoomstart', function(event) { 	// карту начали двигать руками
	// функция отменяет следование карты за курсором, и устанавливает таймер, чтобы вернуть
	// пытается отделить собственные движения карты от юзерских, включая изменение масштаба
	if(userMoveMap) { 	// Убран флаг в куске, двигающем карту за курсором
		//alert('Карту сдвинули событием '+event.type);
		if(event.type == 'zoomstart') userMoveMap = 2; // юзер нажал zoom
		else {
			if(userMoveMap == 2) userMoveMap = true; 	// на это дело сработало movestart - игнорируем
			else {
				followToCursor=false; 	// запретим следование за курсором
				clearTimeout(followPaused); 	// отменим то, что есть
				followPaused = setTimeout('followToCursor=true;',followPause); 	// через время followPause разрешим обратно
			}
		}
	}
});
map.on('zoomend', function(event) {
	if(distCirclesSwitch.checked) distCirclesUpdate();	// нарисуем круги дистанции
});
map.on('moveend', updateClasters); 	// кластеризация точек POI
//map.on("layeradd", function(event) {
//});

// Восстановим слои
var layers = JSON.parse(getCookie('GaladrielMaps')); 	// getCookie from galadrielmap.js
// Занесём слои на карту
if(layers) layers.reverse().forEach(function(layerid){ 	// потому что они там были для красоты последним слоем вверъ
		for (var i = 0; i < mapList.children.length; i++) { 	// для каждого потомка списка mapList
			if (mapList.children[i].id==layerid) { 	// 
				selectMap(mapList.children[i]);
				break;
			}
		}
	});
else {
	for (var i = 0; i < mapList.children.length; i++) { 	// для каждого потомка списка mapList
		if (mapList.children[i].id==defaultMap) { 	// найдём, который из них defaultMap
			selectMap(mapList.children[i]); 	// и покажкм его
			break;
		}
	}
}


// Рисование маршрута
dravingLines.addTo(map);
doRestoreMeasuredPaths(); 	// восстановим из кук сохранённые на устройстве маршруты
routeControlsDeSelect(); 	// сделать кнопки рисования невыбранными

var pointIcon = L.icon({
	iconUrl: 'leaflet-omnivorePATCHED/symbols/point.png',
	iconSize: [32, 37],
	iconAnchor: [16, 37],
	tooltipAnchor: [16,-25],
	className: 'wpIcon',
});
var anchorIcon = L.icon({
	iconUrl: 'leaflet-omnivorePATCHED/symbols/anchor.png',
	iconSize: [32, 37],
	iconAnchor: [16, 37],
	tooltipAnchor: [16,-25],
	className: 'wpIcon'
});
var cautionIcon = L.icon({
	iconUrl: 'leaflet-omnivorePATCHED/symbols/caution.png',
	iconSize: [32, 37],
	iconAnchor: [16, 37],
	tooltipAnchor: [16,-25],
	className: 'wpIcon'
});

/*
map.on('editable:editing', // обязательный обработчик для editable для перересовывания расстояний при изменении пути
	function (e) {
		//console.log('обязательный обработчик для editable start by editable:editing',e);
		// А это норм, что оно глобально?
		if (e.layer instanceof L.Path) e.layer.updateMeasurements();
    }
);
*/
map.on('editable:drawing:end',	function(event) {
	 // выключать кнопку "Начать" при окончании рисования, сделать доступной "Продолжить"
	//console.log('map.on [editable:drawing:end] event.target:',event.target);
	/*
	if(event.layer instanceof L.Marker){
		console.log('[map.on editable:drawing:end] event.layer is a L.marker');
	}
	*/
	if(event.layer instanceof L.Path){
		//console.log('[map.on editable:drawing:end] event.layer is a L.Path');
		routeContinueButton.disabled=false;
	}
	routeCreateButton.checked=false;
});
map.on('editable:vertex:dragstart',	function(event) {
	window.navigator.vibrate(200); // Вибрировать 200ms
});

// центр экрана
let markSize = Math.round(window.innerWidth/5);
//console.log(markSize);
var centerMark = L.marker(map.getBounds().getCenter(), {
	'icon': new L.icon({
		//iconUrl: './img/Crosshair.svg',
		iconUrl: centerMark_markerImg,
		iconSize:     [markSize, markSize], // size of the icon
		iconAnchor:   [markSize/2, markSize/2], // point of the icon which will correspond to marker's location
		className: "centerMarkIcon"	// galadrielmap.css
	}),
	pane: 'overlayPane',	// расположим маркер над тайлами, но ниже всего остального
	zIndexOffset: -1000
});

// Местоположение
// маркеры
var GpsCursor = L.icon({
	iconUrl: './img/gpscursor.png',
	//shadowUrl: '//leafletjs.com/docs/images/leaf-shadow.png',
	iconSize:     [120, 120], // size of the icon
	//shadowSize:   [50, 64], // size of the shadow
	iconAnchor:   [60, 60], // point of the icon which will correspond to marker's location
	//shadowAnchor: [4, 62],  // the same for the shadow
	//popupAnchor:  [-3, -76] // point from which the popup should open relative to the iconAnchor
});

// курсор
var NoGpsCursor = L.icon({	// этот значёк может показываться и при пропаже связи с сервером, а в этом случае загрузить картинку не удастся. Попытка загрузить её заранее не получилась: Leaflet, видимо, убивает долго неиспользуемые объекты. Или сборщик мусора?
	iconUrl: './img/gpscursor.png',
	iconSize:     [120, 120], // size of the icon
	iconAnchor:   [60, 60], // point of the icon which will correspond to marker's location
	className: "NoGpsCursorIcon"	// galadrielmap.css
});
var velocityCursor = L.icon({
	iconUrl: './img/1x1.png',
	//iconUrl: './img/minLine.svg',
});
var NoCursor = L.icon({
	iconUrl: './img/1x1.png',
	iconSize: [0, 0], // size of the icon
});
var cursor = L.marker(startCenter, {
	icon: GpsCursor,
	rotationAngle: 0, // начальный угол поворота маркера
	rotationOrigin: "50% 50%", 	// вертим маркер вокруг центра
	pane: 'overlayPane',	// расположим маркер над тайлами, но ниже всего остального
	zIndexOffset: -500
});
// указатель скорости
var velocityVector = L.marker(cursor.getLatLng(), {
	'icon': velocityCursor,
	rotationAngle: 0, // начальный угол поворота маркера
	opacity: 0.1,
	pane: 'overlayPane',	// расположим маркер над тайлами, но ниже всего остального
	zIndexOffset: -501
});
velocityVectorLengthInMnDisplay.innerHTML = velocityVectorLengthInMn; 	// нарисуем цену вектора скорости на панели управления
// Точность ГПС
var GNSScircle = L.circle(cursor.getLatLng(), {
	'radius': 10,
	'color':'#000000',
	'weight':0,
	'opacity':0.1,
	'fillOpacity':0.1,
	pane: 'overlayPane',	// расположим маркер над тайлами, но ниже всего остального
	zIndexOffset: -502
});
// Круги дистанции
var distCirclesRadius = [200,500,1000,2000]
var distCircles = [
	L.circle(cursor.getLatLng(), {
		radius: distCirclesRadius[0],
		color: '#FD00DB',
		weight: 1,
		opacity: 0.3,
		fill: false,
		pane: 'overlayPane',
		zIndexOffset: -503
	}),
	L.circle(cursor.getLatLng(), {
		radius: distCirclesRadius[1],
		color: '#FD00DB',
		weight: 1,
		opacity: 0.3,
		fill: false,
		pane: 'overlayPane',
		zIndexOffset: -503
	}),
	L.circle(cursor.getLatLng(), {
		radius: distCirclesRadius[2],
		color: '#FD00DB',
		weight: 1,
		opacity: 0.3,
		fill: false,
		pane: 'overlayPane',
		zIndexOffset: -503
	}),
	L.circle(cursor.getLatLng(), {
		radius: distCirclesRadius[3],
		color: '#FD00DB',
		weight: 1,
		opacity: 0.3,
		fill: false,
		pane: 'overlayPane',
		zIndexOffset: -503
	})
];

// Курсор: объединение всех фигур
var positionCursor = L.layerGroup([GNSScircle,velocityVector,cursor]);
if(distCirclesSwitch.checked) distCircles.forEach(circle => circle.addTo(positionCursor));

// Для визуализации collisionDetector
var collisionIcon = L.icon({
	iconUrl: './img/redbulletdot.svg',
	iconSize:     [60, 60],
	iconAnchor:   [30, 30]
});
var collisionDirectionIcon = L.icon({
	iconUrl: './img/redArrow.svg',
	iconSize:     [20,24],
	iconAnchor:   [10,30]
});
var collisisonDetected = L.layerGroup(); 	// слой, на котором рисуются значки возможных столкновений collisionDetector
var collisionDirectionsCursor = L.layerGroup();	// слой с указателями направлений на опасности столкновений

/////////////////////////// collisionDetector test ///////////////////////////////
//var collisisonAreas = L.layerGroup(); 	// для тестовых целей collisionDetector
/////////////////////////// end collisionDetector test ///////////////////////////////

// MOB marker
var mobIcon = L.icon({ 	// 
	iconUrl: mob_markerImg,	// options.js
	//iconUrl: "img/mob.png",
	iconSize: [32, 37],
	//iconSize: [64, 74],
	iconAnchor: [16, 37],
	//iconAnchor: [32, 74],
	tooltipAnchor: [16,-25],
	className: 'mobIcon'	
});
// линия между положением и указанным маркером MOB
var toMOBline = L.polyline([], { 	
	color: 'red',
	weight: 10,
	opacity:0.3,
})

// восстановим маркеры
var mobMarker = getCookie('GaladrielMapMOB'); 	// getCookie from galadrielmap.js
//console.log('Восстановление MOB: mobMarker',mobMarker);
if(mobMarker) {
	// Восстановим мультислой маркеров из GeoJSON, а потом каждому маркеру в мультислое присвоим иконку, которая в GeoJSON не сохраняется.
	mobMarker = L.geoJSON(JSON.parse(mobMarker));
	mobMarker.eachLayer(function (layer) {
		if(layer instanceof L.Marker)	{
			layer.setIcon(mobIcon);
			currentMOBmarker = layer; 	// последний станет текущим
		}
		else mobMarker.removeLayer(layer); 	// Считаем, что это toMOBline, и там больше ничего такого нет
	});
	mobMarker.addLayer(toMOBline);
	mobMarker.addTo(map);
	mobMarker.eachLayer(function (layer) { 	// сделаем каждый маркер draggable
		if(layer instanceof L.Marker)	{	
			layer.dragging.enable(); 	// переключение возможно, только если маркер на карте
			layer.on('dragend', function(event){
				//console.log("New MOB marker from server data dragged end, send to server new coordinates",currentMOBmarker);
				sendMOBtoServer(); 
			}); 	// отправим на сервер новые сведения, когда перемещение маркера закончилось. Если просто указать функцию -- в sendMOBtoServer передаётся event. Если в одну строку -- всё равно передаётся event. Что за???
		}
	});
}
else mobMarker = L.layerGroup().addLayer(toMOBline);

//var mobMarker = L.layerGroup().addLayer(toMOBline);

// Позиционирование
// Realtime периодическое обновление
var spatialWebSocket; // 
var TPVdata = {};	// буфер с данными позиционирования, скорости и направления
var lastDataUpdate;	// момент последнего обновления координат

function spatialWebSocketStart(){
//
	let checkDataFreshInterval;	// объект периодического запуска проверки свежести данных
	
	spatialWebSocket = new WebSocket(`ws://${document.location.host}/signalk/v1/stream?subscribe=none`); 	//  подписываться будем отдельно, по событию websocketOnOpen

	spatialWebSocket.onopen = function(event) {
		console.log("[spatialWebSocket open] Connection established");
		
		// Если сервера не было, то списки могли изменится после его перезапуска
		// не уверен, что стоит заморачиваться с перегрузкой всех списков, перепоказом маршрутов и вот этим всем...
		//console.log("[spatialWebSocket open] Track list and route list refreshing");
		//listPopulate(routeList,routeDirURI,false,restoreDisplayedRoutes);	// список маршрутов, асинхронно
		//listPopulate(trackList,trackDirURI,true,function(){chkDisplayedList(trackList,trackDisplayed);});	// список путей, показывать текущий, асинхронно
		// Однако, проверить, не изменился ли файл лога стоит? Оно асинхронно
		loggingCheck();	// запрашивает статус записи лога, по результатам зажигает лампочки, изменяет trackList, делает текущий трек, etc.
		
		TPVsubscribe.subscribe.forEach(subscribe => subscribe.minPeriod = minWATCHinterval);	//  signalKsubscribe в options.js
		event.target.send(JSON.stringify(TPVsubscribe));	// подписываемся на получение данных
		console.log("[spatialWebSocket open] Subscribe sended");
		// Хоть какая-то проверка актуальности координат -- за отсутствием чего-то такого в SignalK
		if(useSystemTimeouts){	// options.js
			// Попытка сделать правильно в этом кривом SignalK
			// Во-первых, meta.timeout реально вообще нигде нет. По идее, его должен указывать производитель данных, но нет.
			// Во-вторых, к этому моменту может вообще не быть navigation, а по подписке не присылается meta
			// В-третьих, в доке указано, что должен быть meta.timeout, но если смотреть по аналогии с units, скажем, то оно meta.properties.longitude.timeout Как оно правильно -- неизвестно
			let timeout = getSelfPathC('navigation.position.meta.timeout');
			if(timeout) PosFreshBefore = timeout*1000;
			timeout = getSelfPathC(ConfigDepthProp+'.meta.timeout');
			if(timeout) DepthFreshBefore = timeout*1000;
		}
		// Попытка переподключения к серверу, если позиция давно не обновлялась
		checkDataFreshInterval = setInterval(function (){
			//console.log('[checkDataFreshInterval] PosFreshBefore=',PosFreshBefore,'lastDataUpdate=',Date.now()-lastDataUpdate);
			if((Date.now()-lastDataUpdate)>PosFreshBefore){
				console.log('The latest TPV data was received too long ago, trying to reconnect for checking.');
				spatialWebSocket.close(1000,'The latest data was received too long ago');
			}
		},PosFreshBefore);
	}; // end spatialWebSocket.onopen

	spatialWebSocket.onmessage = function(event) {
		//console.log(`[message] Данные TPV получены с сервера: ${event.data}`);
		let data;
		try{
			data = JSON.parse(event.data);
		}
		catch(error){
			console.log('spatialWebSocket: Parsing inbound data',error.message);
			return;
		}
		//console.log('From SignalK',data,vesselSelf);
		if(!data.updates){	// ответ на какой-то запрос
			//console.log('Other From SignalK',data);
			if(data.self){	// handshaiking
				//vesselSelf = data.self.substring(8);	// отрезано vessels.
				vesselSelf = data.self;
			}
			return;
		}
		for(let update of data.updates){
			//console.log('update:',update);
			if(!update.values) continue;	// непонятно, почему может не быть values, но иногда их нет
			for(let value of update.values){	// какое-то обновление данных пришло.
				//console.log('[spatialWebSocket.onmessage] recieved data:',data);
				lastDataUpdate = Date.now();
				switch(value.path){
				case 'navigation.position':
					TPVdata.lon = value.value.longitude;
					TPVdata.lat = value.value.latitude;
					//console.log('TPVdata lon lat',TPVdata.lon,TPVdata.lat);
					TPVdata.time = update.timestamp;	// там не требуется unix timestamp, а, наоборот, дата в виде строки
					break;
				case 'navigation.courseOverGroundTrue':
					TPVdata.track = value.value*180/Math.PI;
					break;
				case 'navigation.headingTrue':
					TPVdata.heading = value.value*180/Math.PI;
					break;
				// в принципе, может быть и navigation.headingMagnetic и navigation.headingCompass
				// причём разные (с учётом navigation.magneticDeviation)
				// Кто им доктор?
				case 'navigation.headingMagnetic':
					TPVdata.mheading = value.value*180/Math.PI;
				case 'navigation.headingCompass':
					TPVdata.mheading = value.value*180/Math.PI;
					if(TPVdata.magdev !== undefined) TPVdata.mheading += TPVdata.magdev;
					break;
				case 'navigation.speedOverGround':	// что именно -- устанавливается в конфигурации плагина
				case 'navigation.speedThroughWater':
					TPVdata.speed = value.value;
					break;
				case 'environment.depth.belowSurface':	// что именно -- устанавливается в конфигурации плагина
				case 'environment.depth.belowKeel':
				case 'environment.depth.belowTransducer':
					TPVdata.depth = value.value;
					break;
				case 'navigation.magneticVariation':	// The magnetic variation (declination) at the current position that must be added to the magnetic heading to derive the true heading. Easterly variations are positive and Westerly variations are negative (in Radians). магнитное склонение
					TPVdata.magvar = value.value*180/Math.PI;
					break;
				case 'navigation.magneticDeviation':	// Magnetic deviation of the compass at the current headingCompass погрешность компаса, магнитная девиация
					TPVdata.magdev = value.value*180/Math.PI;
					break;
				}
			}
		}
		data = null;	// хотя это, по-видимому, не освободит память.
		realtimeTPVupdate(TPVdata);	// показываем новое каждый тик
		
		/////////////////////////// collisionDetector test ///////////////////////////////
		//displayCollisionAreas();	// показываем отладочную информацию предупреждения о столкновениях
		/////////////////////////// end collisionDetector test ///////////////////////////////
		
	}; // end spatialWebSocket.onmessage

	spatialWebSocket.onclose = function(event) {
		console.log(`spatialWebSocket closed: connection broken with code ${event.code} by reason ${event.reason}`);
		//console.log('lastDataUpdate',lastDataUpdate,Date.now()-lastDataUpdate,'PosFreshBefore*30',PosFreshBefore*30);
		if((Date.now()-lastDataUpdate)>PosFreshBefore*30) {
			positionCursor.remove(); 	// уберём курсор (layerGroup) с карты
			velocityDial.innerHTML = '&nbsp;'; 	// обнулим панель приборов
			courseDisplay.innerHTML = '&nbsp;';
			locationDisplay.innerHTML = '&nbsp;';
			depthDial.innerHTML = '';
		}
		else {
			cursor.setIcon(NoGpsCursor);	// заменим курсор (значёк) на серый
			positionTimeDisplay.innerHTML = '<blink>&infin;</blink>';	// но моргать оно не будет, потому что чтобы разные придурки не моргали где ни попадя, этот тег запретили всем совсем навсегда. Ибо нефиг!
		}
		//MOBtab.className='disabled'; 	// если нет курсора (координат) -- невозможно включить режим MOB. Это плохая идея.
		clearInterval(checkDataFreshInterval);	// остановить периодическую проверку свежести
		window.setTimeout(spatialWebSocketStart, 3000); 	// перезапустим сокет через  секунд. В каком контексте здесь вызывается callback -- мне осталось непонятным, поэтому сокет ваще глобален
	}; // end spatialWebSocket.onclose

	spatialWebSocket.onerror = function(error) {
	  console.log(`[spatialWebSocket error] ${error.message}`);
	}; // end spatialWebSocket.onerror

	function realtimeTPVupdate(gpsdData) {
		//console.log('index.html [realtimeTPVupdate] gpsdData',gpsdData);
		// Положение неизвестно
		if(gpsdData.error || (gpsdData.lon == null)||(gpsdData.lat == null) || (gpsdData.lon == undefined)||(gpsdData.lat == undefined)) { 	// 
			console.log('No spatial info in GPSD data',gpsdData);
			positionCursor.remove(); 	// уберём курсор с карты
			velocityDial.innerHTML = '&nbsp;'; 	// обнулим панель приборов
			courseDisplay.innerHTML = '&nbsp;';
			locationDisplay.innerHTML = '&nbsp;';
			depthDial.innerHTML = '';
			//MOBtab.className='disabled'; 	// если нет курсора (координат) -- невозможно включить режим MOB. Это плохая идея.
			return;
		}
		// Свежее ли положение известно? -- установим курсор в положение
		//MOBtab.className=''; 	// координаты появились -- можно включить режим MOB
		positionCursor.invoke('setLatLng',[gpsdData.lat,gpsdData.lon]); // установим координаты всех маркеров
		if(distCirclesSwitch.checked) distCirclesUpdate();	// нарисуем круги дистанции
		let positionTime = new Date(gpsdData.time);
		let now = new Date();
		//console.log('gpsdData.time:',gpsdData.time,'now',now,'now-positionTime',(now-positionTime)/1000);
		if((now-positionTime) > PosFreshBefore) {
			cursor.setIcon(NoGpsCursor); 	// свежее положение было определено раньше, чем PosFreshBefore милисекунд назад
		}
		else cursor.setIcon(GpsCursor);
		// Информация о свежести данных на приборной панели
		positionTimeDisplay.innerHTML = (Math.round((now-positionTime)/100)/10).toFixed(1);
		
		// Показ скорости и прочего
		//console.log('Index gpsdData',gpsdData.speed);
		// https://wiki.openstreetmap.org/wiki/Zoom_levels, тайл имеет размер 256 пикселей
		var metresPerPixel = (40075016.686 * Math.abs(Math.cos(cursor.getLatLng().lat*(Math.PI/180))))/Math.pow(2, map.getZoom()+8); 	// in WGS84
		if(gpsdData.speed==undefined || gpsdData.speed==null) {
			velocityDial.innerHTML = '&nbsp;';
			velocityVector.setIcon(NoCursor);
		}
		else {
			//var velocity = Math.round((gpsdData.speed*60*60/1000)*10)/10; 	// скорость от gpsd - в метрах в секунду
			var velocity = Math.round((gpsdData.speed*60*60/1000)*10)/10; 	// скорость от gpsd - в метрах в секунду

			velocityDial.innerHTML = velocity;
			// Установим длину указателя скорости за  минуты
			var velocityCursorLength = gpsdData.speed*60*velocityVectorLengthInMn; 	// метров  за  минуты
			velocityCursorLength = Math.round(velocityCursorLength/metresPerPixel);	// пикселей
			//console.log('map.getZoom='+map.getZoom()+'\nmetresPerPixel='+metresPerPixel+'\ngpsdData.speed='+gpsdData.speed+'\nvelocityCursorLength='+velocityCursorLength);
			velocityCursor.options.iconSize=[5,velocityCursorLength];
			velocityCursor.options.iconAnchor=[3,velocityCursorLength];
			velocityVector.setIcon(velocityCursor); 	// изменить иконку у маркера
		}
		if(gpsdData.depth) {
			//console.log('gpsdData.depth:',gpsdData.depth);
			depthDial.innerHTML = '<br><br><div style="font-size:50%;">'+dashboardDepthMesTXT+'</div><br>';
			if((now-positionTime) > DepthFreshBefore) {	// тайм-штамп в SignalK один на посылку данных
				depthDial.innerHTML += '<div style="color:silver;">'+(Math.round(gpsdData.depth*100)/100)+'</div>';
			}
			else depthDial.innerHTML += '<div>'+(Math.round(gpsdData.depth*100)/100)+'</div>';
			depthDial.innerHTML += '<br><div style="font-size:50%;">'+dashboardMeterMesTXT+'</div>';
		}
		else {
			depthDial.innerHTML = '';
		}
		
		// Направление
		//console.log('Index gpsdData',gpsdData.track);
		if(gpsdData.track == null || gpsdData.track == undefined) {	// нет путевого угла
			if(gpsdData.heading !== undefined) {	// зато есть курс
				positionCursor.invoke('setRotationAngle',gpsdData.heading); // повернём все маркеры
				courseDisplay.innerHTML = Math.round(gpsdData.heading); // покажем направление на приборной панели
				// Заменим подписи
				dashboardCourseTXT.innerHTML = i18n.stringsandliterals.dashboardHeadingTXT
				dashboardCourseAltTXT.innerHTML = i18n.stringsandliterals.dashboardHeadingAltTXT
			}
			else if(gpsdData.mheading !== undefined){	// или магнитный курс
				if(gpsdData.magvar !== undefined) {		// если есть склонение -- он истинный курс
					let heading = gpsdData.mheading + gpsdData.magvar;
					positionCursor.invoke('setRotationAngle',heading); // повернём все маркеры
					courseDisplay.innerHTML = Math.round(heading); // покажем направление на приборной панели
					// Заменим подписи
					dashboardCourseTXT.innerHTML = i18n.stringsandliterals.dashboardHeadingTXT
					dashboardCourseAltTXT.innerHTML = i18n.stringsandliterals.dashboardHeadingAltTXT
				}
				else {
					positionCursor.invoke('setRotationAngle',gpsdData.mheading); // повернём все маркеры
					courseDisplay.innerHTML = Math.round(gpsdData.mheading); // покажем направление на приборной панели
					// Заменим подписи
					dashboardCourseTXT.innerHTML = i18n.stringsandliterals.dashboardMHeadingTXT
					dashboardCourseAltTXT.innerHTML = i18n.stringsandliterals.dashboardMHeadingAltTXT
				}
			}
			else {	// нет никакой информации о направлении
				courseDisplay.innerHTML = '&nbsp;';
				positionCursor.invoke('setRotationAngle',0); // повернём все маркеры
			}
		}
		else {
			velocityVector.setRotationAngle(gpsdData.track);
			if(gpsdData.heading !== undefined) cursor.setRotationAngle(gpsdData.heading);
			else if((gpsdData.mheading !== undefined) && (gpsdData.magvar !== undefined)) cursor.setRotationAngle(gpsdData.mheading + gpsdData.magvar);
			else cursor.setRotationAngle(gpsdData.track);
			courseDisplay.innerHTML = Math.round(gpsdData.track); // покажем направление на приборной панели
			// Заменим подписи, вдруг до этого не было путевого угла
			dashboardCourseTXT.innerHTML = i18n.stringsandliterals.dashboardCourseTXT
			dashboardCourseAltTXT.innerHTML = i18n.stringsandliterals.dashboardCourseAltTXT
		}
		/*
		// Визуализация collisionDetector
		// оказывается, размеры ниже устанавливаются не в смысле значка, а как прямоугольник
		// на экране, параллельный осям. Поэтому перед изменением размеров надо
		// повернуть значёк в исходное положение
		collisionAreaMarker.setRotationAngle(0); 
		collisionAreaIcon.options.iconSize=[velocityCursorLength/10,velocityCursorLength];
		collisionAreaIcon.options.iconAnchor=[velocityCursorLength/20,velocityCursorLength];
		collisionAreaMarker.setIcon(collisionAreaIcon);
		collisionAreaMarker.setLatLng(cursor.getLatLng() );// положение
		collisionAreaMarker.setRotationAngle(gpsdData.heading); // повернём маркер
		*/
		positionCursor.addTo(map); 	// добавить курсор на карту

		// Окружность точност ГПС
		var errGNSS = (+gpsdData.errX+gpsdData.errY)/2;
		if(!errGNSS) errGNSS = 10; // метров
		if(errGNSS/metresPerPixel > 15) GNSScircle.setRadius(errGNSS); 	// кружок точности больше кружка курсора
		else GNSScircle.setRadius(0);

		// Карту в положение курсора
		//console.log("[spatialWebSocket.onmessage] followToCursor=", followToCursor);
		if(followToCursor && !noFollowToCursor) { 	// если сказано следовать курсору, и это разрешено глобально
			userMoveMap = false;
			map.setView(cursor.getLatLng()); // подвинем карту на позицию маркера. Почему-то этот процесс вызывает перерисовывание (всех?) видимых полилиний. Видимо, это нормально?
			userMoveMap = true;
		}

		// координаты курсора с точностью знаков
		lat = Math.round(cursor.getLatLng().lat*10000)/10000; 	 	// широта
		lng = Math.round(cursor.getLatLng().lng*10000)/10000; 	 	// долгота
		locationDisplay.innerHTML = latTXT+' '+lat+'<br>'+longTXT+' '+lng;	
		followSwitch.checked = !noFollowToCursor; 	// выставим переключатель на панели Настроек в текущее положение	
		
		// MOB
		if(map.hasLayer(mobMarker)){ 	// если показывается мультислой с маркерами MOB 
			//console.log('[spatialWebSocket.onmessage] mobMarker.getLayers():',mobMarker.getLayers());
			let latlng1 = cursor.getLatLng();
			let latlng2 = currentMOBmarker.getLatLng();
			toMOBline.setLatLngs([latlng1,latlng2]); 	// обновим линию к текущему маркеру MOB
			// информация о MOB на панели
			const azimuth = bearing(latlng1, latlng2);
			//console.log('azimuth=',azimuth,latlng1, latlng2)
			azimuthMOBdisplay.innerHTML = Math.round(azimuth);
			distanceMOBdisplay.innerHTML = Math.round(latlng1.distanceTo(latlng2));
			locationMOBdisplay.innerHTML = latTXT+' '+Math.round(currentMOBmarker.getLatLng().lat*10000)/10000+' '+longTXT+' '+Math.round(currentMOBmarker.getLatLng().lng*10000)/10000;	
			let heading = gpsdData.track || gpsdData.heading || gpsdData.mheading;
			if(heading) {
				let relBearing = azimuth-heading+22.5;	// половина от 45 против часовой стрелке
				if(relBearing<0) relBearing = 360+relBearing;
				relBearing = Math.floor(relBearing/45); 	// курсовой угол (relative bearing) / 45 градусов -- номер сектора, против часовой стрелки
				if(relBearing>7) relBearing = 0;
				directionMOBdisplay.innerHTML = relBearingTXT[relBearing];
			}
		}
	}; // end function realtimeTPVupdate
}; // end function spatialWebSocketStart

spatialWebSocketStart(); 	// запускам периодическую функцию получать TPV

function spatialWebSocketStop(message=''){
	console.log('Stop recieve TPV',);
	spatialWebSocket.close(1000,message);
} // end function spatialWebSocketStop


// Данные AIS
// 	Запуск периодических функций
var aisWebSocket;	// будет глобальный сокет для AIS
// буфер с данными AIS
// Но у нас уже есть vehicles? В vehicles -- показываемые объекты Leaflet,
// а здесь -- все сведения о целях AIS, показываемых сейчас, или нет.
// Если цель сперва протухнет, а потом снова объявится -- у нас уже есть вся статическая информация о ней.
var AISdata = {};	
function watchAISstart() {
	//console.log('AIS switched ON');
	let checkDataFreshInterval;	// объект периодического запуска проверки свежести данных

	aisWebSocket = new WebSocket(`ws://${document.location.host}/signalk/v1/stream?subscribe=none`); 	//  подписываться будем отдельно, по событию websocketOnOpen
	aisWebSocket.onopen = function(event) {
		console.log("[aisWebSocket open] Connection established");
		AISsubscribe.subscribe.forEach(subscribe => subscribe.minPeriod = minWATCHinterval);	//  AISsubscribe в options.js
		event.target.send(JSON.stringify(AISsubscribe));	// подписываемся на получение данных
		console.log("[aisWebSocket open] Subscribe sended");
		// Хоть какая-то проверка актуальности целей AIS -- за отсутствием чего-то такого в SignalK
		//console.log('PosFreshBefore=',PosFreshBefore);
		checkDataFreshInterval = setInterval(function (){
			for(const vehicle in vehicles){
				if((!vehicles[vehicle].options.timestamp) || ((Date.now()-vehicles[vehicle].options.timestamp*1000)<aisFreshBefore)) continue;
				//console.log(vehicle,'протух в vehicles',(Date.now()-vehicles[vehicle].options.timestamp*1000)/1000,aisFreshBefore/1000);
				vehicles[vehicle].remove();
				vehicles[vehicle] = null;
				delete vehicles[vehicle];
			}
		},PosFreshBefore);
	}; // end aisWebSocket.onopen

	aisWebSocket.onmessage = function(event) {
		//console.log(`[aisWebSocket message] Данные AIS получены с сервера: ${event.data}`);
		let data;
		try{
			data = JSON.parse(event.data);
		}
		catch(error){
			console.log('aisWebSocket: Parsing inbound data',error.message);
			return;
		}
		if(!data.updates){	// handshaiking
			return;
		}
		//console.log('data.context:',data.context,vesselSelf,AISdata);
		// Было бы неправильно показывать AIS только при наличии своих координат
		// но пока их нет -- нет и vesselSelf, а значит, среди целей AIS может быть и сам я
		if(data.context == vesselSelf) {
			if(vesselSelf in AISdata){
				delete AISdata[vesselSelf];
				realtimeAISupdate(JSON.parse('{"class":"AIS","ais":'+JSON.stringify(AISdata)+'}'));	// 
			}
			return;
		}
		
		//const vessel = data.context.substring(8);	// vessels.
		const vessel = data.context;
		if(!AISdata[vessel]) AISdata[vessel] = {};
		//if(AISdata[vessel].shipname == 'Sample Ship Name') console.log('Before',JSON.stringify(AISdata[vessel]));
		//AISdata[vessel].mmsi = vessel.slice(vessel.lastIndexOf('mmsi')+5);
		for(let update of data.updates){
			for(let value of update.values){
				//console.log(data.context,value.path,value.value);
				//console.log(data.context,value);
				//if(data.context == 'vessels.urn:mrn:imo:mmsi:357535405') console.log(data.context,value.value);
				switch(value.path){
				case '':	// похоже, правильный путь - "", а не name, но тогда нет места для mmsi, ибо оно тоже по пути "". 
							// Но, видимо, по одному пути может быть много объектов?
							// Короче говоря, фактически name и mmsi -- это свойства, находящиеся по пути ""
							// При этом в подписку по "" попадают и communication и registrations
							// Это тоже объекты в ""?
					//console.log(data.context,value.value);
					for(const key in value.value){
						switch(key){
						case 'name':
							AISdata[vessel].shipname = value.value[key];
							break;
						case 'mmsi':
							AISdata[vessel].mmsi = value.value[key];
							break;
						case 'registrations':
							AISdata[vessel].imo = value.value[key].imo;
							break;
						case 'communication':
							//console.log(data.context,key,value.value[key]);
							if(value.value[key].callsignVhf) AISdata[vessel].callsign = value.value[key].callsignVhf;
							if(value.value[key].netAIS) AISdata[vessel].netAIS = value.value[key].netAIS;
							break;
						}
					}
					break;
				case 'name':
					AISdata[vessel].shipname = value.name;
					break;
				case 'mmsi':
					AISdata[vessel].mmsi = value.mmsi;
					break;
				case 'registrations.imo':
					AISdata[vessel].imo = value.imo;
					break;
				case 'communication.callsignVhf':
					AISdata[vessel].callsign = value.value;
					break;
				case 'communication.netAIS':
					AISdata[vessel].netAIS = value.value;
					break;
				case 'design.aisShipType':
					AISdata[vessel].shiptype = value.value.id;
					AISdata[vessel].shiptype_text = value.value.name;
					break;
				case 'design.draft':
					if(!isNaN(value.value.maximum)) AISdata[vessel].draught = value.value.maximum;
					else if(!isNaN(value.value.current)) AISdata[vessel].draught = value.value.current;
					break;
				case 'design.length':
					if(!isNaN(value.value.overall)) AISdata[vessel].length = value.value.overall;
					break;
				case 'design.beam':
					if(!isNaN(value.value)) AISdata[vessel].beam = value.value;
					break;
				case 'navigation.position':
					AISdata[vessel].lon = value.value.longitude;
					AISdata[vessel].lat = value.value.latitude;
					//console.log(vessel,'navigationDatetime=',AISdata[vessel].navigationDatetime,`AISdata[vessel].timestamp=`,AISdata[vessel].timestamp,Math.round(Date.parse(update.timestamp)/1000)-AISdata[vessel].timestamp);
					if(!AISdata[vessel].navigationDatetime) AISdata[vessel].timestamp = Math.round(Date.parse(update.timestamp)/1000);	// Если navigation.datetime не посылается
					break;
				case 'navigation.state':
					if(isNaN(value.value)) AISdata[vessel].status_text = value.value;
					else AISdata[vessel].status = value.value;
					break;
				case 'navigation.courseOverGroundTrue':
					if(!isNaN(value.value)) AISdata[vessel].course = Math.round(value.value*180/Math.PI);
					break;
				case 'navigation.headingTrue':
					if(!isNaN(value.value)) AISdata[vessel].heading = Math.round(value.value*180/Math.PI);
					break;
				case 'navigation.speedOverGround':
					if(!isNaN(value.value)) AISdata[vessel].speed = value.value;
					break;
				case 'navigation.destination.commonName':
					if(value.value) AISdata[vessel].destination = value.value;
					break;
				case 'navigation.destination.eta':
					if(value.value) AISdata[vessel].eta = value.value;
					break;
				case 'navigation.datetime':
					const ts = Math.round(Date.parse(value.value)/1000);
					AISdata[vessel].timestamp = ts;
					// значение navigation.datetime, чтобы знать, что его получаем по подписке.
					// Если нет -- используется таймштамп координат. Но то, что SignalK не указывает
					// navigation.datetime для AIS -- странно. В сообщениях AIS есть время.
					AISdata[vessel].navigationDatetime = ts;	
					//console.log(vessel,'navigation.datetime=',value.value,AISdata[vessel].timestamp);
					break;
				}
			}
		}
		//if(AISdata[vessel].shipname == 'Sample Ship Name') {
			//console.log('After',JSON.stringify(AISdata[vessel]));
			//console.log('After',AISdata[vessel]);
			//console.log('aisWebSocket.onmessage AISdata:',AISdata);
		//}
		data = null;
		realtimeAISupdate(JSON.parse('{"class":"AIS","ais":'+JSON.stringify(AISdata)+'}'));	// хрен его знает где и почему портится AISdata, поэтому передаём "по значению".
		//realtimeAISupdate({"class":"AIS","ais":AISdata});	// 
		
		/////////////////////////// collisionDetector test ///////////////////////////////
		//displayCollisionAreas();	// показываем отладочную информацию предупреждения о столкновениях
		/////////////////////////// end collisionDetector test ///////////////////////////////
		
	}; // end aisWebSocket.onmessage

	aisWebSocket.onclose = function(event) {
		console.log(`aisWebSocket closed: connection broken with code ${event.code} by reason ${event.reason}`);
		if(DisplayAISswitch.checked ) window.setTimeout(watchAISstart, 3000); 	// перезапустим сокет через  секунд, если в интерфейсе указано
		for(const vehicle in vehicles){
			vehicles[vehicle].remove();	// удалить из DOM
			vehicles[vehicle] = null;
			delete vehicles[vehicle];
		}
		clearInterval(checkDataFreshInterval);	// остановить периодическую проверку свежести
	}; // end aisWebSocket.onclose

	aisWebSocket.onerror = function(error) {
	  console.log(`[aisWebSocket error] ${error.message}`);
	}; 	//end aisWebSocket.onerror

	function realtimeAISupdate(aisClass) {
	// Показывает цели AIS, перечисленные в aisClass.ais
	// те, которых там нет -- перестаёт показывать
	let aisData = aisClass.ais;
	//console.log(aisData); 	// массив с данными целей
	//console.log('',JSON.stringify(aisData));
	//console.log(DisplayAISswitch);
	let vehiclesVisible = [];
	const defaultSymbol = [0.8,0, -0.3,0.35, -0.3,-0.35]; 	// треугольник вправо, расстояния от центра, через которые нарисуют polyline
	const noHeadingSymbol = [0.35,0, 0,0.35, -0.35,0, 0,-0.35]; 	// ромбик
	const netAISdefaultSymbol = [1*0.5,0, 0.25*0.5,0.25*0.5, 0,1*0.5, -0.25*0.5,0.5*0.5, -1*0.5,0.75*0.5, -1*0.5,-0.75*0.5, -0.25*0.5,-0.5*0.5, 0,-1*0.5, 0.25*0.5,-0.25*0.5]; 	// треугольник, расстояния от центра, через которые нарисуют polyline
	const netAISnoHeadingSymbol = [1*0.35,0, 0.75*0.35,0.5*0.35, 1*0.35,1*0.35, 0.5*0.35,0.75*0.35, 0,1*0.35, -0.5*0.35,0.75*0.35, -1*0.35,1*0.35, -0.75*0.35,0.5*0.35, -1*0.35,0, -0.75*0.35,-0.5*0.35, -1*0.35,-1*0.35, -0.5*0.35,-0.75*0.35, 0,-1*0.35, 0.5*0.35,-0.75*0.35, 1*0.35,-1*0.35, 0.75*0.35,-0.5*0.35]; 	// ромбик: правый, верхний, левый, нижний ПРотив часовой от правого?
	for(const vehicle in aisData){
		//console.log(vehicle,aisData[vehicle]);
		if(vehicle.toLowerCase() == 'error') break;
		if((aisData[vehicle].lat === null) || (aisData[vehicle].lon === null) || (aisData[vehicle].lat === undefined) || (aisData[vehicle].lon === undefined)) continue;	// не показываем цели без координат
		//console.log(vehicle,'протух на',(Date.now()-aisData[vehicle].timestamp*1000)/1000,aisFreshBefore/1000);
		if((Date.now()-aisData[vehicle].timestamp*1000)>aisFreshBefore) continue;	// не показываем протухшие цели. Они могут появляться быстрее, чем удаляются из списка aisData
		if(!vehicles[vehicle]) { 	// global var, массив layers с целями
			//console.log('Create layers',vehicle,aisData[vehicle]);
			vehicles[vehicle] = L.trackSymbol(L.latLng(0,0),{
				trackId: vehicle,
				leaderTime: velocityVectorLengthInMn*60,
				fill: true,
				fillOpacity: 1.0,
				stroke: true,
				opacity: 1.0,
				weight: 1.0,
			}).addTo(map);
		}
		// Значёк будем переприсваивать каждый раз, потому что в SignalK неизвестно, когда придёт
		// признак aisData[vehicle].netAIS
		if(aisData[vehicle].netAIS) { 	// цель получена от netAIS
			vehicles[vehicle].setDefaultSymbol(netAISdefaultSymbol);
			vehicles[vehicle].setNoHeadingSymbol(netAISnoHeadingSymbol);
		}
		else { 	// цель получена от локального приёмника AIS
			vehicles[vehicle].setDefaultSymbol(defaultSymbol);
			vehicles[vehicle].setNoHeadingSymbol(noHeadingSymbol);
		}
		//console.log(vehicles[vehicle]);
		vehicles[vehicle].addData(aisData[vehicle]); 	// обновим данные		
		vehiclesVisible.push(vehicle); 	// запомним, какие есть
	}
	for(const vehicle in vehicles){
		if(vehiclesVisible.includes(vehicle) && DisplayAISswitch.checked) continue; 	// типа, синхронизация... clearInterval -- асинхронная функция, и может не успеть отключить опрос AIS до того, как цели будут убраны с экрана. Тогда они уберутся здесь.
		vehicles[vehicle].remove();
		vehicles[vehicle] = null;
		delete vehicles[vehicle];
	}
	} // end function realtimeAISupdate

return aisWebSocket
} // end function watchAISstart

watchAISstart(); 	// запускам периодическую функцию смотреть AIS
DisplayAISswitch.checked = true;

function watchAISstop(message=''){
let res = false;
try {
	aisWebSocket.close(1000,message);
	console.log('AIS switched OFF');
	res = true;
}
catch(err) {};
// даже если неуспешно, всё равно
for(const vehicle in vehicles){	// уберём цели AIS с карты
	vehicles[vehicle].remove();
	vehicles[vehicle] = null;
	delete vehicles[vehicle];
};
collisionDirectionsCursor.clearLayers();	// очистим слой указателей направлений на опасности столкновений на курсоре
collisionDirectionsCursor.remove();
collisisonDetected.clearLayers();	// очистим слой 
collisisonDetected.remove();
return res;
} // end function watchAISstop

function watchAISswitching(){
let res;
if(DisplayAISswitch.checked) {
	res = watchAISstart();
	//console.log('[watchAISswitching] START res=',res,'DisplayAISswitch.checked=',DisplayAISswitch.checked,);
	if(!res) DisplayAISswitch.checked = false;
}
else {
	res = watchAISstop('Dispalying AIS stopped');
	//console.log('[watchAISswitching] STOP res=',res,'DisplayAISswitch.checked=',DisplayAISswitch.checked,);
	if(!res) DisplayAISswitch.checked = true;
}
}; // end function watchAISswitching

// Уведомления
var alarmWebSocket;
function alarmWebSocketStart(){
//
	alarmWebSocket = new WebSocket(`ws://${document.location.host}/signalk/v1/stream?subscribe=none`); 	//  подписываться будем отдельно, по событию websocketOnOpen
	alarmWebSocket.onopen = function(event) {
		console.log("[alarmWebSocket open] Connection established");
		event.target.send(JSON.stringify(notificationaSubscribe));	// подписываемся на получение данных
		if(map.hasLayer(mobMarker)){ 	// если показывается мультислой с маркерами MOB
			sendMOBtoServer(); 	// отдадим данные MOB для передачи на сервер, на всякий случай -- вдруг там не знают
		}
		collisionDirectionsCursor.addTo(positionCursor);	// слой с указателями направлений на опасности столкновений
		console.log("[alarmWebSocket open] Subscribe sended");
	}; // end alarmWebSocket.onopen

	alarmWebSocket.onmessage = function(event) {
		//console.log(`[message] Данные TPV получены с сервера: ${event.data}`);
		let data;
		try{
			data = JSON.parse(event.data);
		}
		catch(error){
			console.log('alarmWebSocket: Parsing inbound data',error.message);
			return;
		}
		//console.log('From SignalK',data,vesselSelf);
		if(!data.updates){	// ответ на какой-то запрос
			//console.log('Other From SignalK',data);
			if(data.self){	// handshaiking
			}
			return;
		}
		byUpdates: for(let update of data.updates){
			//console.log('update:',update);
			if(!update.values) continue;	// непонятно, почему может не быть values, но иногда их нет
			for(let value of update.values){	// какое-то обновление данных пришло.
				//console.log('recieved data',data);
				switch(value.path){
				case 'notifications.mob':
					// pre MOB -- даже если у нас нет координат, полезно показать маркеры MOB
					if(value.value === null) { 	// режим MOB надо выключить
						if(map.hasLayer(mobMarker)){ 	// если показывается мультислой с маркерами MOB
							MOBclose(); 	// пришло, что режима MOB нет -- завершим его
						}
						continue byUpdates;
					}
					//console.log('режим MOB есть, пришли новые данные');
					if(value.value.source == instanceSelf) continue byUpdates;	// это нами же установленный MOB
					let mobMarkerJSON = value.value.position;	// Это GeoJSON
					//console.log('mobMarkerJSON:',mobMarkerJSON);
					// Восстановим мультислой маркеров из GeoJSON, а потом каждому маркеру в мультислое присвоим иконку, которая в GeoJSON не сохраняется.
					mobMarker.remove(); 	// убрать мультислой-маркер с карты
					mobMarker = null; 	// реально удалим объект
					mobMarker = L.geoJSON(mobMarkerJSON); 	// создадим новый объект
					mobMarker.eachLayer(function (layer) {
						if(layer instanceof L.Marker)	{
							layer.setIcon(mobIcon);
							layer.on('click', function(ev){
								currentMOBmarker = ev.target;
								clearCurrentStatus(); 	// удалим признак current у всех маркеров
								currentMOBmarker.feature.properties.current = true;
								sendMOBtoServer(); 	// отдадим данные MOB для передачи на сервер
							}); 	// текущим будет маркер, по которому кликнули
							//console.log('Маркеры в полученной информации MOB ',layer);
							if(layer.feature.properties.current) currentMOBmarker = layer; 	// текущим станет указанный в переданных данных
						}
						else mobMarker.removeLayer(layer); 	// Считаем, что это toMOBline, и там больше ничего такого нет
					});
					mobMarker.addLayer(toMOBline);
					mobMarker.addTo(map); 	// покажем мультислой с маркерами MOB
					mobMarker.eachLayer(function (layer) { 	// сделаем каждый маркер draggable
						if(layer instanceof L.Marker)	{	
							layer.dragging.enable(); 	// переключение возможно, только если маркер на карте
							layer.on('dragend', function(event){
								//console.log("New MOB marker from server data dragged end, send to server new coordinates",currentMOBmarker);
								sendMOBtoServer(); 
							}); 	// отправим на сервер новые сведения, когда перемещение маркера закончилось. Если просто указать функцию -- в sendMOBtoServer передаётся event. Если в одну строку -- всё равно передаётся event. Что за???
						}
					});
					//console.log(mobMarker);
					break;
				case 'notifications.danger.collision':
					//console.log('recieved collision data',value.value);
					//console.log('collision data',value.value ? value.value.vessels.length : 'null');
					//console.log('collision data',value.value ? value.value.collisionSegments : 'null');
					if(!DisplayAISswitch.checked) break;	// если в параметрах не указано показывать AIS
					collisisonDetected.clearLayers();	// очистим слой 
					collisionDirectionsCursor.clearLayers();
					if((value.value === null)||(!DisplayAISswitch.checked)){	// переключатель "Показывать AIS" выключен
						collisisonDetected.remove();	// удалить -- откуда? Мы-то знаем, что с map...
						break;	// switch
					}
					for(const vesselID in value.value.vessels){
						//console.log('Collision',value.value.vessels[vesselID]);
						// Значки опасностей
						collisisonDetected.addLayer( L.marker(value.value.vessels[vesselID], {
							icon: collisionIcon,
							opacity: 0.5,
							zIndexOffset: -1000
						}));
						// Указатели вокруг курсора
						const selflatLng = cursor.getLatLng();
						if(selflatLng){
							//console.log('Опасность с',bearing(selflatLng, value.value.vessels[vesselID]));
							collisionDirectionsCursor.addLayer( L.marker(selflatLng, {
								icon: collisionDirectionIcon,
								opacity: 0.75,
								rotationAngle: bearing(selflatLng, value.value.vessels[vesselID])
							}));
						}
					};
					/*////////////////////////// collisionDetector test ///////////////////////////////
					for(let vesselID in value.value.collisionSegments){
						//console.log(value.value.collisionSegments[vesselID]);
						
						// Общий объемлющий прямоугольник
						if(value.value.collisionSegments[vesselID].unitedSquareAreas){
							value.value.collisionSegments[vesselID].unitedSquareAreas.forEach(area => {
								//console.log('unitedSquareArea:',area);
								let polyline = [
									[area.topLeft.latitude,area.topLeft.longitude],
									[area.bottomRight.latitude,area.topLeft.longitude],
									[area.bottomRight.latitude,area.bottomRight.longitude],
									[area.topLeft.latitude,area.bottomRight.longitude],
									[area.topLeft.latitude,area.topLeft.longitude]
								];
								collisisonDetected.addLayer(L.polyline(polyline,{color: 'green',weight: 2,}));
							});
						}
						
						// Пересекающиеся отрезки
						if(value.value.collisionSegments[vesselID].segments){
							value.value.collisionSegments[vesselID].segments.forEach(segment => {
								//console.log('collisionSegment:\n',segment);
								let polyline = [
									[segment[0][0].latitude,segment[0][0].longitude],
									[segment[0][1].latitude,segment[0][1].longitude]
								];
								collisisonDetected.addLayer(L.polyline(polyline,{color: 'yellow',weight: 6,}));
								polyline = [
									[segment[1][0].latitude,segment[1][0].longitude],
									[segment[1][1].latitude,segment[1][1].longitude]
								];
								collisisonDetected.addLayer(L.polyline(polyline,{color: 'yellow',weight: 6,}));
							});
						}
					};
					/*////////////////////////// end collisionDetector test ///////////////////////////////
					collisisonDetected.addTo(map);	// а collisionDirectionsCursor часть positionCursor, и оно и так addTo(map)
					break;
				};
			};
		};
	}; // end alarmWebSocket.onmessage

	alarmWebSocket.onclose = function(event) {
		console.log(`alarmWebSocket closed: connection broken with code ${event.code} by reason ${event.reason}`);
		window.setTimeout(alarmWebSocketStart, 3000); 	// перезапустим сокет через  секунд. В каком контексте здесь вызывается callback -- мне осталось непонятным, поэтому сокет ваще глобален
		collisisonDetected.clearLayers();	// очистим слой 
		collisionDirectionsCursor.clearLayers();
		collisisonDetected.remove();
		collisionDirectionsCursor.remove();
	}; // end alarmWebSocket.onclose

	alarmWebSocket.onerror = function(error) {
	  console.log(`[alarmWebSocket error] ${error.message}`);
	}; // end alarmWebSocket.onerror
}; // end function alarmWebSocketStart

alarmWebSocketStart(); 	// запускам периодическую функцию получать оповещения

function alarmWebSocketStop(message=''){
	console.log('Stop recieve TPV',);
	alarmWebSocket.close(1000,message);
} // end function alarmWebSocketStop


// 	Запуск периодических функций	 realtime -- в galadrielmap.js, функция, асинхронно обращающаяся к uri

// Динамическое обновление показываемых маршрутов
var updateRoutesInterval = setInterval(realtime,2000,updateRouteServerURI,routeUpdate);	//

function routeUpdate(changedRouteNames) {
// Вызывается из-под realtime 
//console.log('changedRouteNames',changedRouteNames);
if(routeDisplayed.innerHTML.trim() == "") { 	// не показывается ни одного маршрута
	updateRoutesInterval = clearInterval(updateRoutesInterval); 	// прекратим следить за изменениями
	routeDisplayed.addEventListener("DOMNodeInserted", function (event) { 	// добавим обработчик события изменения DOM
		if(! updateRoutesInterval) { 	// никогда не должно быть здесь updateRoutesInterval, но оно может не успеть
			updateRoutesInterval = setInterval(function(){realtime(updateRouteServerURI,routeUpdate);},2000); 	// запустим слежение за изменением показываемых маршрутов
		}
		routeDisplayed.removeEventListener("DOMNodeInserted", this); 	// удаляем обработчик
	}
	, false);
	return;
}
// в связи с возможностью наличия в trackDisplayed дублирующихся id --
// может быть, вместо document.getElementById(name) сделать цикл по потомкам routeDisplayed? 
if(!Array.isArray(changedRouteNames)) return;	// там может быть объект с сообщением об ошибке, например, связи
let node;
for(const name of changedRouteNames){
	node = document.getElementById(name); 	// однако, в trackDisplayed могут быть те же имена. Забить? в querySelector требуется экранирование пробелов и спец-символов. Это секс.
	if(node.parentNode != routeDisplayed) continue; 	// элемент, конечно, всегда есть, нужно, чтобы он показывался
	//console.log(node);
	savedLayers[name].remove(); 	// удалим слой с карты
	savedLayers[name] = null; 	// удалим сам слой
	displayRoute(node); 	// перересуем маршрут
}
} // end  function routeUpdate

// Текущий трек
// Должен обновляться, даже если обновлялка не описана в конфиге, потому что трек может писать кто-то ещё. 
// Т.е. в худшем случае -- мы не знаем, обновляется ли currentTrack, или нет
var currentTrackUpdateProcess;
// Не нужно тут запускать, потому что в этот момент всё равно нет currentTrackName,
// а запускать безусловно -- неправильно, потому что currentTrackName может так и не быть,
// может быть выключен показ трека юзером и что-нибудь ещё.
// С другой стороны, если указано "Текущий трек всегда показывается" -- следилка должна быть запущена
// потому что запись трека может включить кто-то где-то.
startCurrentTrackUpdate();



// Сохранение переменных
var savePositionProcess = setInterval(doSavePosition,savePositionEvery); 	// велим сохранять всё каждые savePositionEvery
// Всегда после загрузки страницы "Следовать за курсором" включено
document.getElementById("followSwitch").checked = true; 	// выставим переключатель на панели Настроек в правильное положение
</script>
</html>
